/*class Circuit {
  constructor(width, height, x, y) {
    this.width = width;
    this.height = height;
    this.x = x;
    this.y = y;
  }
}*/

// https://stackoverflow.com/questions/19171778/createjs-container-recursion-loop-for-nested-objects
function recur(thisContainer) {
    let children = [];

    //console.log("recur()");
    var containerLength = thisContainer.numChildren;
    var thisChild;
    for(var i=0; i<containerLength; i++) {
        thisChild = thisContainer.getChildAt(i);
        children.push([thisChild, thisContainer]);
        //console.log(thisChild);
        if(thisChild instanceof createjs.Container) {
            children = children.concat(recur(thisChild));
        }
    }

    return children;
}

// returns [child, parent]
function getStageItem(name, children) {
    for (let i = 0; i < children.length; i++) {
        if (children[i][0].name === name) {
            return children[i];
        }
    }
}

const MAX_ZOOM = 8;
const MIN_ZOOM = 0.01;

const XOR_BULB_SIZE = 1;
const HALF_ADDER_BULB_SIZE = 2;
const FULL_ADDER_BULB_SIZE = 4;
const FOUR_BIT_ADDER_BULB_SIZE = 8;
const LIGHT_ON_COLOR = "#f66";
const LIGHT_OFF_COLOR = "#fdd";
const TRADIUS = 20;
const STROKE_WIDTH = 1;
const XOR_STROKE_WIDTH = STROKE_WIDTH * 3;
const HALF_ADDER_STROKE_WIDTH = STROKE_WIDTH * 6;
const FULL_ADDER_STROKE_WIDTH = STROKE_WIDTH * 12;
const FOUR_BIT_ADDER_STROKE_WIDTH = STROKE_WIDTH * 24;
const DASH = 6;

class AndGate {
    constructor(stage, tradius, strokeWidth, transistorGraphic, resistorGraphic, groundGraphic, useLights, useCover) {
        this.coverColor = "pink";
        this.coverName = "cover-" + (Math.random() * 99999999).toString();
        this.useCover = useCover;
        this.stage = stage;

        this.input1 = false;
        this.input2 = false;
        this.output = false;

        this.useLights = useLights;
        this.tradius = tradius;
        this.strokeWidth = strokeWidth;
        this.transistorGraphic = transistorGraphic;
        this.resistorGraphic = resistorGraphic;
        this.groundGraphic = groundGraphic;
        this.width = this.tradius * 8;
        this.height = this.tradius * 16;
        this.plusStrokeWidth = Math.floor(this.tradius / 7);
        this.bulbSize = 0.5;
        this.draw();
        //console.log(this.plusStrokeWidth);

        this.setInput(this.input1, this.input2);
    }

    // children generated by recur(stage)
    /*removeCover(children) {
        const [child, parent] = getStageItem(this.coverName, children);
        parent.removeChild(child);
    }*/

    setInput(value1, value2) {
        this.input1 = value1;
        this.input2 = value2;
        this.output = value1 && value2;

        if (this.input1) {
            this.inputLight1.fillCommand.style = LIGHT_ON_COLOR;
        } else {
            this.inputLight1.fillCommand.style = LIGHT_OFF_COLOR;
        }

        if (this.input2) {
            this.inputLight2.fillCommand.style = LIGHT_ON_COLOR;
        } else {
            this.inputLight2.fillCommand.style = LIGHT_OFF_COLOR;
        }

        if (this.output) {
            this.outputLight.fillCommand.style = LIGHT_ON_COLOR;
        } else {
            this.outputLight.fillCommand.style = LIGHT_OFF_COLOR;
        }
    } 
    getOutput() {
        return this.output;
    }

    draw() {

        const THIS = this;

        this.container = new createjs.Container();
        //this.container.name = "and-gate"

        const t = this.transistorGraphic.container.clone(true);
        t.x = Math.floor(this.width / 2) - this.tradius;
        t.y = Math.floor(this.height / 4) - this.tradius;
        this.container.addChild(t);

        const t2 = this.transistorGraphic.container.clone(true);
        t2.x = Math.floor(this.width / 2) - this.tradius;
        t2.y = Math.floor(this.height / 4 * 3) - this.tradius;
        this.container.addChild(t2);

        const r1 = this.resistorGraphic.container.clone(true);
        r1.x = Math.floor(this.width / 2) + this.tradius - this.resistorGraphic.stepwidth;
        r1.y = Math.floor(this.height / 4 * 3) + Math.floor(this.tradius * 1.2);
        this.container.addChild(r1);

        const r1wiretop = new createjs.Shape();
        r1wiretop
            .graphics
            .setStrokeStyle(this.strokeWidth)
            .beginStroke("black")
            .moveTo(Math.floor(this.width / 2) + this.tradius, Math.floor(this.height / 4 * 3) + Math.floor(this.tradius * 1))
            .lineTo(Math.floor(this.width / 2) + this.tradius, Math.floor(this.height / 4 * 3) + Math.floor(this.tradius * 1.2))
            .endStroke();
        this.container.addChild(r1wiretop);

        const r1wirebottom = new createjs.Shape();
        r1wirebottom
            .graphics
            .setStrokeStyle(this.strokeWidth)
            .beginStroke("black")
            .moveTo(Math.floor(this.width / 2) + this.tradius, Math.floor(this.height / 4 * 3) + Math.floor(this.tradius * 1.2) + this.resistorGraphic.height)
            .lineTo(Math.floor(this.width / 2) + this.tradius, Math.floor(this.height / 4 * 3) + Math.floor(this.tradius * 1.4) + this.resistorGraphic.height)
            .endStroke();
        this.container.addChild(r1wirebottom);

        const g1 = this.groundGraphic.container.clone(true);
        g1.x = Math.floor(this.width / 2) + this.tradius - Math.floor(this.groundGraphic.width / 2);
        g1.y = Math.floor(this.height / 4 * 3) + Math.floor(this.tradius * 1.4) + this.resistorGraphic.height
        this.container.addChild(g1);

        const r2 = this.resistorGraphic.container.clone(true);
        r2.regX = this.resistorGraphic.width / 2;
        r2.regY = this.resistorGraphic.height / 2;
        r2.rotation = 90
        r2.x = this.resistorGraphic.height / 2;
        r2.y = this.resistorGraphic.width / 2;

        const r2wrap = new createjs.Container();
        r2wrap.addChild(r2);

        r2wrap.x = Math.floor(this.width / 2) - this.tradius - this.resistorGraphic.height - Math.floor(this.tradius * 0.2);
        r2wrap.y = Math.floor(this.height / 4) - Math.floor(this.resistorGraphic.width / 2);
        this.container.addChild(r2wrap);



        const r3 = this.resistorGraphic.container.clone(true);
        r3.regX = this.resistorGraphic.width / 2;
        r3.regY = this.resistorGraphic.height / 2;
        r3.rotation = 90
        r3.x = this.resistorGraphic.height / 2;
        r3.y = this.resistorGraphic.width / 2;

        const r3wrap = new createjs.Container();
        r3wrap.addChild(r3);

        r3wrap.x = Math.floor(this.width / 2) - this.tradius - this.resistorGraphic.height - Math.floor(this.tradius * 0.2);
        r3wrap.y = Math.floor(this.height / 4 * 3) - Math.floor(this.resistorGraphic.width / 2);
        this.container.addChild(r3wrap);


        const inputWire1 = new createjs.Shape();
        inputWire1
            .graphics
            .setStrokeStyle(this.strokeWidth)
            .beginStroke("black")
            .moveTo(Math.floor(this.width / 2) - this.tradius, Math.floor(this.height / 4))
            .lineTo(Math.floor(this.width / 2) - this.tradius - Math.floor(this.tradius * 0.2), Math.floor(this.height / 4))
            .endStroke();
        this.container.addChild(inputWire1);

        const inputWire1b = new createjs.Shape();
        inputWire1b
            .graphics
            .setStrokeStyle(this.strokeWidth)
            .beginStroke("black")
            .moveTo(Math.floor(this.width / 2) - this.tradius, Math.floor(this.height / 4 * 3))
            .lineTo(Math.floor(this.width / 2) - this.tradius - Math.floor(this.tradius * 0.2), Math.floor(this.height / 4 * 3))
            .endStroke();
        this.container.addChild(inputWire1b);


        const inputWire2 = new createjs.Shape();
        inputWire2
            .graphics
            .setStrokeStyle(this.strokeWidth)
            .beginStroke("black")
            .moveTo(0, Math.floor(this.height / 4))
            .lineTo(r2wrap.x, Math.floor(this.height / 4))
            .endStroke();
        this.container.addChild(inputWire2);

        const inputWire2b = new createjs.Shape();
        inputWire2b
            .graphics
            .setStrokeStyle(this.strokeWidth)
            .beginStroke("black")
            .moveTo(0, Math.floor(this.height / 4 * 3))
            .lineTo(r2wrap.x, Math.floor(this.height / 4 * 3))
            .endStroke();
        this.container.addChild(inputWire2b);








        const plusVertGapLen = (Math.floor(this.height / 2) - this.tradius * 2) - (Math.floor(this.height / 2) - this.tradius *2.2)

        const plusVert = new createjs.Shape();
        plusVert
            .graphics
            .setStrokeStyle(this.plusStrokeWidth)
            .beginStroke("black")
            .moveTo(Math.floor(this.width / 2) + this.tradius, plusVertGapLen * 4 + this.tradius * 2)//Math.floor(this.height / 2) - this.tradius *2.2)
            .lineTo(Math.floor(this.width / 2) + this.tradius, plusVertGapLen + this.tradius * 2)
            .endStroke();
        this.container.addChild(plusVert);


        const plusHorz = new createjs.Shape();
        plusHorz
            .graphics
            .setStrokeStyle(this.plusStrokeWidth)
            .beginStroke("black")
            .moveTo(Math.floor(this.width / 2) + this.tradius - plusVertGapLen * 1.5, plusVertGapLen * 2.5  + this.tradius * 2)
            .lineTo(Math.floor(this.width / 2) + this.tradius + plusVertGapLen * 1.5, plusVertGapLen * 2.5 + this.tradius * 2)
            .endStroke();

        this.container.addChild(plusHorz);


        const outwire1 = new createjs.Shape();
        outwire1
            .graphics
            .setStrokeStyle(this.strokeWidth)
            .beginStroke("black")
            .moveTo(this.tradius * 5, this.tradius * 13)
            .lineTo(this.tradius * 5 + Math.floor(this.tradius), this.tradius * 13)
            .endStroke();
        this.container.addChild(outwire1);

        const outwire7 = new createjs.Shape();
        outwire7
            .graphics
            .setStrokeStyle(this.strokeWidth)
            .beginStroke("black")
            .moveTo(this.tradius * 6, this.tradius * 13)
            .lineTo(this.tradius * 6, this.tradius * 8)
            .endStroke();
        this.container.addChild(outwire7);


        const outwire3 = new createjs.Shape();
        outwire3
            .graphics
            .setStrokeStyle(this.strokeWidth)
            .beginStroke("black")
            .moveTo(this.tradius * 5, this.tradius * 11)
            .lineTo(this.tradius * 5, this.tradius * 5)
            .endStroke();
        this.container.addChild(outwire3);


        const outwire4 = new createjs.Shape();
        outwire4
            .graphics
            .setStrokeStyle(this.strokeWidth)
            .beginStroke("black")
            .moveTo(this.tradius * 5 + Math.floor(this.tradius), Math.floor(this.height / 2))
            .lineTo(this.width, Math.floor(this.height / 2))
            .endStroke();
        this.container.addChild(outwire4);




        if (this.useLights) {
            this.inputLight1 = new Light(this.tradius, this.strokeWidth, this.bulbSize, function() {
                const input = !THIS.input1;
                THIS.setInput(input, THIS.input2);
                THIS.stage.update()
            });

            const inLightWire1 = new createjs.Shape();
            inLightWire1
                .graphics
                .setStrokeStyle(this.strokeWidth)
                .beginStroke("black")
                .moveTo(Math.floor(this.tradius * 0.2) + this.inputLight1.radius, Math.floor(this.height / 4 ))
                .lineTo(Math.floor(this.tradius * 0.2) + this.inputLight1.radius, Math.floor(this.height / 4 ) - this.inputLight1.radius)
                .endStroke();
            this.container.addChild(inLightWire1);

            this.inputLight1.container.x = Math.floor(this.tradius * 0.2);
            this.inputLight1.container.y = Math.floor(this.height / 4) - this.inputLight1.radius * 2.5;
            this.container.addChild(this.inputLight1.container);


            this.inputLight2 = new Light(this.tradius, this.strokeWidth, this.bulbSize, function() {
                console.log(1);
                const input = !THIS.input2;
                THIS.setInput(THIS.input1, input);
                THIS.stage.update()
            });
            const inLightWire2 = new createjs.Shape();
            inLightWire2
                .graphics
                .setStrokeStyle(this.strokeWidth)
                .beginStroke("black")
                .moveTo(Math.floor(this.tradius * 0.2) + this.inputLight2.radius, Math.floor(this.height / 4 * 3))
                .lineTo(Math.floor(this.tradius * 0.2) + this.inputLight2.radius, Math.floor(this.height / 4 * 3) - this.inputLight2.radius)
                .endStroke();
            this.container.addChild(inLightWire2);

            this.inputLight2.container.x = Math.floor(this.tradius * 0.2);
            this.inputLight2.container.y = Math.floor(this.height / 4 * 3) - this.inputLight2.radius * 2.5;
            this.container.addChild(this.inputLight2.container);






            this.outputLight = new Light(this.tradius, this.strokeWidth, this.bulbSize);
            
            const outLightWire = new createjs.Shape();
            outLightWire
                .graphics
                .setStrokeStyle(this.strokeWidth)
                .beginStroke("black")
                .moveTo(this.width - this.outputLight.radius * 2 - Math.floor(this.tradius * 0.2) + this.outputLight.radius, Math.floor(this.height / 2))
                .lineTo(this.width - this.outputLight.radius * 2 - Math.floor(this.tradius * 0.2) + this.outputLight.radius, Math.floor(this.height / 2) - this.outputLight.radius)
                .endStroke();
            this.container.addChild(outLightWire);


            this.outputLight.container.x = this.width - this.outputLight.radius * 2 - Math.floor(this.tradius * 0.2);
            this.outputLight.container.y = Math.floor(this.height / 2) - this.outputLight.radius * 2.5;
            this.container.addChild(this.outputLight.container);
        }




        const dash = DASH;



        this.outline = new createjs.Shape();
        this.outline
            .graphics
            .beginStroke("gray")
            .setStrokeStyle(this.strokeWidth)
            .setStrokeDash([dash, dash], 0)
            .beginFill("rgba(255, 255, 255, 0.01")
            .drawRect(0, 0, this.width, this.height)
        this.outline.name = "outline-" + this.coverName
        this.container.addChild(this.outline);




        this.coverContainer = new createjs.Container();
        this.coverContainer.name = this.coverName + "-container";
        this.cover = new createjs.Shape();
        this.cover.name = this.coverName;
        /*const THIS = this;
        this.cover.rmCover = function() {
            THIS.removeCover()
        }*/
        this.cover.graphics
            .beginStroke("black")
            .setStrokeStyle(this.strokeWidth)
            //.setStrokeDash([dash, dash], 0)
            .beginFill(this.coverColor)
            .drawRect(0, 0, this.width, this.height)
        this.coverContainer.addChild(this.cover);


        var text = new createjs.Text("And", this.tradius * 4 + "px Arial", "black");
        text.x = this.tradius * 3;
        text.y = this.tradius * 4;
        text.textBaseline = "alphabetic"
        text.rotation = 90
        this.coverContainer.addChild(text)


        //this.cover.on("click", function(event) { console.log("clicked"); }, null, false, null, true)
        //this.cover.on("click", function(event) { console.log("clicked"); })

        this.container.addChild(this.coverContainer)

        //this.cover.alpha = 0.5




        this.container.regX = this.width / 2;
        this.container.regY = this.width / 2;
        this.container.rotation = -90;
        const oldContainer = this.container;
        this.container = new createjs.Container();
        this.container.addChild(oldContainer);
        oldContainer.x = this.width / 2; 
        oldContainer.y = this.height / 4;
    }
}

class OrGate {
    constructor(stage, tradius, strokeWidth, transistorGraphic, resistorGraphic, groundGraphic, useLights) {
        this.stage = stage;
        this.useCover = true;
        this.coverColor = "orange";
        this.coverName = "cover-" + (Math.random() * 99999999).toString();
        
        this.input1 = false;
        this.input2 = false;
        this.output = false;
        this.useLights = useLights;
        this.tradius = tradius;
        this.strokeWidth = strokeWidth;
        this.transistorGraphic = transistorGraphic;
        this.resistorGraphic = resistorGraphic;
        this.groundGraphic = groundGraphic;
        this.width = this.tradius * 8;
        this.height = this.tradius * 16;
        this.plusStrokeWidth = Math.floor(this.tradius / 7);
        this.bulbSize = 0.5;
        this.draw();
        //console.log(this.plusStrokeWidth);

        this.setInput(this.input1, this.input2);
    }

    setInput(value1, value2) {
        this.input1 = value1;
        this.input2 = value2;
        this.output = value1 || value2;

        if (this.input1) {
            this.inputLight1.fillCommand.style = LIGHT_ON_COLOR;
        } else {
            this.inputLight1.fillCommand.style = LIGHT_OFF_COLOR;
        }

        if (this.input2) {
            this.inputLight2.fillCommand.style = LIGHT_ON_COLOR;
        } else {
            this.inputLight2.fillCommand.style = LIGHT_OFF_COLOR;
        }

        if (this.output) {
            this.outputLight.fillCommand.style = LIGHT_ON_COLOR;
        } else {
            this.outputLight.fillCommand.style = LIGHT_OFF_COLOR;
        }
    }
    getOutput() {
        return this.output;
    }

    draw() {

        this.inLeftX = Math.floor(this.height / 4);
        this.inRightX = Math.floor(this.height / 4 * 3);
        const THIS = this;

        this.container = new createjs.Container();

        const t = this.transistorGraphic.container.clone(true);
        t.x = Math.floor(this.width / 2) - this.tradius;
        t.y = Math.floor(this.height / 4) - this.tradius;
        this.container.addChild(t);

        const t2 = this.transistorGraphic.container.clone(true);
        t2.x = Math.floor(this.width / 2) - this.tradius;
        t2.y = Math.floor(this.height / 4 * 3) - this.tradius;
        this.container.addChild(t2);

        const r1 = this.resistorGraphic.container.clone(true);
        r1.x = Math.floor(this.width / 2) + this.tradius - this.resistorGraphic.stepwidth;
        r1.y = Math.floor(this.height / 4 * 3) + Math.floor(this.tradius * 1.2);
        this.container.addChild(r1);

        const r1wiretop = new createjs.Shape();
        r1wiretop
            .graphics
            .setStrokeStyle(this.strokeWidth)
            .beginStroke("black")
            .moveTo(Math.floor(this.width / 2) + this.tradius, Math.floor(this.height / 4 * 3) + Math.floor(this.tradius * 1))
            .lineTo(Math.floor(this.width / 2) + this.tradius, Math.floor(this.height / 4 * 3) + Math.floor(this.tradius * 1.2))
            .endStroke();
        this.container.addChild(r1wiretop);

        const r1wirebottom = new createjs.Shape();
        r1wirebottom
            .graphics
            .setStrokeStyle(this.strokeWidth)
            .beginStroke("black")
            .moveTo(Math.floor(this.width / 2) + this.tradius, Math.floor(this.height / 4 * 3) + Math.floor(this.tradius * 1.2) + this.resistorGraphic.height)
            .lineTo(Math.floor(this.width / 2) + this.tradius, Math.floor(this.height / 4 * 3) + Math.floor(this.tradius * 1.4) + this.resistorGraphic.height)
            .endStroke();
        this.container.addChild(r1wirebottom);

        const g1 = this.groundGraphic.container.clone(true);
        g1.x = Math.floor(this.width / 2) + this.tradius - Math.floor(this.groundGraphic.width / 2);
        g1.y = Math.floor(this.height / 4 * 3) + Math.floor(this.tradius * 1.4) + this.resistorGraphic.height
        this.container.addChild(g1);

        const r2 = this.resistorGraphic.container.clone(true);
        r2.regX = this.resistorGraphic.width / 2;
        r2.regY = this.resistorGraphic.height / 2;
        r2.rotation = 90
        r2.x = this.resistorGraphic.height / 2;
        r2.y = this.resistorGraphic.width / 2;

        const r2wrap = new createjs.Container();
        r2wrap.addChild(r2);

        r2wrap.x = Math.floor(this.width / 2) - this.tradius - this.resistorGraphic.height - Math.floor(this.tradius * 0.2);
        r2wrap.y = Math.floor(this.height / 4) - Math.floor(this.resistorGraphic.width / 2);
        this.container.addChild(r2wrap);



        const r3 = this.resistorGraphic.container.clone(true);
        r3.regX = this.resistorGraphic.width / 2;
        r3.regY = this.resistorGraphic.height / 2;
        r3.rotation = 90
        r3.x = this.resistorGraphic.height / 2;
        r3.y = this.resistorGraphic.width / 2;

        const r3wrap = new createjs.Container();
        r3wrap.addChild(r3);

        r3wrap.x = Math.floor(this.width / 2) - this.tradius - this.resistorGraphic.height - Math.floor(this.tradius * 0.2);
        r3wrap.y = Math.floor(this.height / 4 * 3) - Math.floor(this.resistorGraphic.width / 2);
        this.container.addChild(r3wrap);


        const inputWire1 = new createjs.Shape();
        inputWire1
            .graphics
            .setStrokeStyle(this.strokeWidth)
            .beginStroke("black")
            .moveTo(Math.floor(this.width / 2) - this.tradius, Math.floor(this.height / 4))
            .lineTo(Math.floor(this.width / 2) - this.tradius - Math.floor(this.tradius * 0.2), Math.floor(this.height / 4))
            .endStroke();
        this.container.addChild(inputWire1);

        const inputWire1b = new createjs.Shape();
        inputWire1b
            .graphics
            .setStrokeStyle(this.strokeWidth)
            .beginStroke("black")
            .moveTo(Math.floor(this.width / 2) - this.tradius, Math.floor(this.height / 4 * 3))
            .lineTo(Math.floor(this.width / 2) - this.tradius - Math.floor(this.tradius * 0.2), Math.floor(this.height / 4 * 3))
            .endStroke();
        this.container.addChild(inputWire1b);


        const inputWire2 = new createjs.Shape();
        inputWire2
            .graphics
            .setStrokeStyle(this.strokeWidth)
            .beginStroke("black")
            .moveTo(0, Math.floor(this.height / 4))
            .lineTo(r2wrap.x, Math.floor(this.height / 4))
            .endStroke();
        this.container.addChild(inputWire2);

        const inputWire2b = new createjs.Shape();
        inputWire2b
            .graphics
            .setStrokeStyle(this.strokeWidth)
            .beginStroke("black")
            .moveTo(0, Math.floor(this.height / 4 * 3))
            .lineTo(r2wrap.x, Math.floor(this.height / 4 * 3))
            .endStroke();
        this.container.addChild(inputWire2b);








        const plusVertGapLen = (Math.floor(this.height / 2) - this.tradius * 2) - (Math.floor(this.height / 2) - this.tradius *2.2)

        const plusVert = new createjs.Shape();
        plusVert
            .graphics
            .setStrokeStyle(this.plusStrokeWidth)
            .beginStroke("black")
            .moveTo(Math.floor(this.width / 2) + this.tradius, plusVertGapLen * 4 + this.tradius * 2)//Math.floor(this.height / 2) - this.tradius *2.2)
            .lineTo(Math.floor(this.width / 2) + this.tradius, plusVertGapLen + this.tradius * 2)
            .endStroke();
        this.container.addChild(plusVert);


        const plusHorz = new createjs.Shape();
        plusHorz
            .graphics
            .setStrokeStyle(this.plusStrokeWidth)
            .beginStroke("black")
            .moveTo(Math.floor(this.width / 2) + this.tradius - plusVertGapLen * 1.5, plusVertGapLen * 2.5  + this.tradius * 2)
            .lineTo(Math.floor(this.width / 2) + this.tradius + plusVertGapLen * 1.5, plusVertGapLen * 2.5 + this.tradius * 2)
            .endStroke();

        this.container.addChild(plusHorz);



        const plusVert2 = new createjs.Shape();
        plusVert2
            .graphics
            .setStrokeStyle(this.plusStrokeWidth)
            .beginStroke("black")
            .moveTo(Math.floor(this.width / 2) + this.tradius, plusVertGapLen * 4 + this.tradius * 10)//Math.floor(this.height / 2) - this.tradius *2.2)
            .lineTo(Math.floor(this.width / 2) + this.tradius, plusVertGapLen + this.tradius * 10)
            .endStroke();
        this.container.addChild(plusVert2);


        const plusHorz2 = new createjs.Shape();
        plusHorz2
            .graphics
            .setStrokeStyle(this.plusStrokeWidth)
            .beginStroke("black")
            .moveTo(Math.floor(this.width / 2) + this.tradius - plusVertGapLen * 1.5, plusVertGapLen * 2.5  + this.tradius * 10)
            .lineTo(Math.floor(this.width / 2) + this.tradius + plusVertGapLen * 1.5, plusVertGapLen * 2.5 + this.tradius * 10)
            .endStroke();

        this.container.addChild(plusHorz2);




        const outwire1 = new createjs.Shape();
        outwire1
            .graphics
            .setStrokeStyle(this.strokeWidth)
            .beginStroke("black")
            .moveTo(this.tradius * 5, this.tradius * 13)
            .lineTo(this.tradius * 5 + Math.floor(this.tradius), this.tradius * 13)
            .endStroke();
        this.container.addChild(outwire1);

        const outwire2 = new createjs.Shape();
        outwire2
            .graphics
            .setStrokeStyle(this.strokeWidth)
            .beginStroke("black")
            .moveTo(this.tradius * 5, this.tradius * 5)
            .lineTo(this.tradius * 5 + Math.floor(this.tradius), this.tradius * 5)
            .endStroke();
        this.container.addChild(outwire2);

        const outwire3 = new createjs.Shape();
        outwire3
            .graphics
            .setStrokeStyle(this.strokeWidth)
            .beginStroke("black")
            .moveTo(this.tradius * 5 + Math.floor(this.tradius), this.tradius * 13)
            .lineTo(this.tradius * 5 + Math.floor(this.tradius), this.tradius * 5)
            .endStroke();
        this.container.addChild(outwire3);


        const outwire4 = new createjs.Shape();
        outwire4
            .graphics
            .setStrokeStyle(this.strokeWidth)
            .beginStroke("black")
            .moveTo(this.tradius * 5 + Math.floor(this.tradius), Math.floor(this.height / 2))
            .lineTo(this.width, Math.floor(this.height / 2))
            .endStroke();
        this.container.addChild(outwire4);




        if (this.useLights) {
            this.inputLight1 = new Light(this.tradius, this.strokeWidth, this.bulbSize, function() {
                const input = !THIS.input1;
                THIS.setInput(input, THIS.input2);
                THIS.stage.update()
            });

            const inLightWire1 = new createjs.Shape();
            inLightWire1
                .graphics
                .setStrokeStyle(this.strokeWidth)
                .beginStroke("black")
                .moveTo(Math.floor(this.tradius * 0.2) + this.inputLight1.radius, Math.floor(this.height / 4 ))
                .lineTo(Math.floor(this.tradius * 0.2) + this.inputLight1.radius, Math.floor(this.height / 4 ) - this.inputLight1.radius)
                .endStroke();
            this.container.addChild(inLightWire1);

            this.inputLight1.container.x = Math.floor(this.tradius * 0.2);
            this.inputLight1.container.y = Math.floor(this.height / 4) - this.inputLight1.radius * 2.5;
            this.container.addChild(this.inputLight1.container);


            this.inputLight2 = new Light(this.tradius, this.strokeWidth, this.bulbSize, function() {
                const input = !THIS.input2;
                THIS.setInput(THIS.input1, input);
                THIS.stage.update()
            });

            const inLightWire2 = new createjs.Shape();
            inLightWire2
                .graphics
                .setStrokeStyle(this.strokeWidth)
                .beginStroke("black")
                .moveTo(Math.floor(this.tradius * 0.2) + this.inputLight2.radius, Math.floor(this.height / 4 * 3))
                .lineTo(Math.floor(this.tradius * 0.2) + this.inputLight2.radius, Math.floor(this.height / 4 * 3) - this.inputLight2.radius)
                .endStroke();
            this.container.addChild(inLightWire2);

            this.inputLight2.container.x = Math.floor(this.tradius * 0.2);
            this.inputLight2.container.y = Math.floor(this.height / 4 * 3) - this.inputLight2.radius * 2.5;
            this.container.addChild(this.inputLight2.container);






            this.outputLight = new Light(this.tradius, this.strokeWidth, this.bulbSize);
            
            const outLightWire = new createjs.Shape();
            outLightWire
                .graphics
                .setStrokeStyle(this.strokeWidth)
                .beginStroke("black")
                .moveTo(this.width - this.outputLight.radius * 2 - Math.floor(this.tradius * 0.2) + this.outputLight.radius, Math.floor(this.height / 2))
                .lineTo(this.width - this.outputLight.radius * 2 - Math.floor(this.tradius * 0.2) + this.outputLight.radius, Math.floor(this.height / 2) - this.outputLight.radius)
                .endStroke();
            this.container.addChild(outLightWire);


            this.outputLight.container.x = this.width - this.outputLight.radius * 2 - Math.floor(this.tradius * 0.2);
            this.outputLight.container.y = Math.floor(this.height / 2) - this.outputLight.radius * 2.5;
            this.container.addChild(this.outputLight.container);
        }




        /*const dash = DASH;

        const outline = new createjs.Shape();
        outline
            .graphics
            .beginStroke("gray")
            .setStrokeStyle(this.strokeWidth)
            .setStrokeDash([dash, dash], 0)
            .drawRect(0, 0, this.width, this.height);
        this.container.addChild(outline);*/









        const dash = DASH;



        this.outline = new createjs.Shape();
        this.outline
            .graphics
            .beginStroke("gray")
            .setStrokeStyle(this.strokeWidth)
            .setStrokeDash([dash, dash], 0)
            .beginFill("rgba(255, 255, 255, 0.01")
            .drawRect(0, 0, this.width, this.height)
        this.outline.name = "outline-" + this.coverName
        this.container.addChild(this.outline);




        this.coverContainer = new createjs.Container();
        this.coverContainer.name = this.coverName + "-container";
        this.cover = new createjs.Shape();
        this.cover.name = this.coverName;
        /*const THIS = this;
        this.cover.rmCover = function() {
            THIS.removeCover()
        }*/
        this.cover.graphics
            .beginStroke("black")
            .setStrokeStyle(this.strokeWidth)
            //.setStrokeDash([dash, dash], 0)
            .beginFill(this.coverColor)
            .drawRect(0, 0, this.width, this.height)
        this.coverContainer.addChild(this.cover);


        var text = new createjs.Text("Or", this.tradius * 4 + "px Arial", "black");
        text.x = this.tradius * 3;
        text.y = this.tradius * 6;
        text.textBaseline = "alphabetic"
        text.rotation = 90
        this.coverContainer.addChild(text)


        //this.cover.on("click", function(event) { console.log("clicked"); }, null, false, null, true)
        //this.cover.on("click", function(event) { console.log("clicked"); })

        this.container.addChild(this.coverContainer)








        this.container.regX = this.width / 2;
        this.container.regY = this.width / 2;
        this.container.rotation = -90;
        const oldContainer = this.container;
        this.container = new createjs.Container();
        this.container.addChild(oldContainer);
        oldContainer.x = this.width / 2; 
        oldContainer.y = this.height / 4;
    }
}

class NotGate {
    constructor(stage, tradius, strokeWidth, transistorGraphic, resistorGraphic, groundGraphic, useLights) {
        this.stage = stage;
        this.useCover = true;
        this.coverColor = "beige";
        this.coverName = "cover-" + (Math.random() * 99999999).toString();

        this.input = false;
        this.output = false;

        this.useLights = useLights;
        this.tradius = tradius;
        this.strokeWidth = strokeWidth;
        this.transistorGraphic = transistorGraphic;
        this.resistorGraphic = resistorGraphic;
        this.groundGraphic = groundGraphic;
        this.width = this.tradius * 8;
        this.height = this.tradius * 8;
        this.plusStrokeWidth = Math.floor(this.tradius / 7);
        this.bulbSize = 0.5;
        this.draw();
        //console.log(this.plusStrokeWidth);

        this.setInput(this.input)
    }

    setInput(value) {
        this.input = value;
        this.output = !value;

        if (this.input) {
            this.inputLight.fillCommand.style = LIGHT_ON_COLOR;
            this.outputLight.fillCommand.style = LIGHT_OFF_COLOR;
        } else {
            this.inputLight.fillCommand.style = LIGHT_OFF_COLOR;
            this.outputLight.fillCommand.style = LIGHT_ON_COLOR;
        }
    }

    getOutput() {
        return this.output;
    }

    draw() {
        const THIS = this;

        this.container = new createjs.Container();

        const t = this.transistorGraphic.container.clone(true);
        t.x = Math.floor(this.width / 2) - this.tradius;
        t.y = Math.floor(this.height / 2) - this.tradius;
        this.container.addChild(t);

        


        const plusWire = new createjs.Shape();
        plusWire
            .graphics
            .setStrokeStyle(this.strokeWidth)
            .beginStroke("black")
            .moveTo(Math.floor(this.width / 2) + this.tradius, Math.floor(this.height / 2) - this.tradius)
            .lineTo(Math.floor(this.width / 2) + this.tradius, Math.floor(this.height / 2) - this.tradius * 1.2)
            .endStroke();
        this.container.addChild(plusWire);

        const r1 = this.resistorGraphic.container.clone(true);
        r1.x = Math.floor(this.width / 2) + this.tradius - this.resistorGraphic.stepwidth;
        r1.y = Math.floor(this.height / 2) - this.tradius * 1.2 - this.resistorGraphic.height;
        this.container.addChild(r1);


        const plusWire2 = new createjs.Shape();
        plusWire2
            .graphics
            .setStrokeStyle(this.strokeWidth)
            .beginStroke("black")
            .moveTo(r1.x + this.resistorGraphic.stepwidth, r1.y)
            .lineTo(r1.x + this.resistorGraphic.stepwidth, r1.y - this.tradius * 0.4)
            .endStroke();
        this.container.addChild(plusWire2);

        //const plusLen = Math.floor(this.tradius / 2.5)

        const plusVertGapLen = (Math.floor(this.height / 2) - this.tradius * 2) - (Math.floor(this.height / 2) - this.tradius *2.2)
        //console.log(this.plusStrokeWidth)

        const plusVert = new createjs.Shape();
        plusVert
            .graphics
            .setStrokeStyle(this.plusStrokeWidth)
            .beginStroke("black")
            .moveTo(Math.floor(this.width / 2) + this.tradius, plusVertGapLen * 4)//Math.floor(this.height / 2) - this.tradius *2.2)
            .lineTo(Math.floor(this.width / 2) + this.tradius, plusVertGapLen)
            .endStroke();
        this.container.addChild(plusVert);


        const plusHorz = new createjs.Shape();
        plusHorz
            .graphics
            .setStrokeStyle(this.plusStrokeWidth)
            .beginStroke("black")
            .moveTo(Math.floor(this.width / 2) + this.tradius - plusVertGapLen * 1.5, plusVertGapLen * 2.5)
            .lineTo(Math.floor(this.width / 2) + this.tradius + plusVertGapLen * 1.5, plusVertGapLen * 2.5)
            .endStroke();

        this.container.addChild(plusHorz);




        const inputWire1 = new createjs.Shape();
        inputWire1
            .graphics
            .setStrokeStyle(this.strokeWidth)
            .beginStroke("black")
            .moveTo(Math.floor(this.width / 2) - this.tradius, Math.floor(this.height / 2))
            .lineTo(Math.floor(this.width / 2) - this.tradius - Math.floor(this.tradius * 0.2), Math.floor(this.height / 2))
            .endStroke();
        this.container.addChild(inputWire1);

        const r2 = this.resistorGraphic.container.clone(true);
        r2.regX = this.resistorGraphic.width / 2;
        r2.regY = this.resistorGraphic.height / 2;
        r2.rotation = 90
        r2.x = this.resistorGraphic.height / 2;
        r2.y = this.resistorGraphic.width / 2;

        const r2wrap = new createjs.Container();
        r2wrap.addChild(r2);


        r2wrap.x = Math.floor(this.width / 2) - this.tradius - this.resistorGraphic.height - Math.floor(this.tradius * 0.2);
        r2wrap.y = Math.floor(this.height / 2) - Math.floor(this.resistorGraphic.width / 2);

        this.container.addChild(r2wrap);

        const inputWire2 = new createjs.Shape();
        inputWire2
            .graphics
            .setStrokeStyle(this.strokeWidth)
            .beginStroke("black")
            .moveTo(0, Math.floor(this.height / 2))
            .lineTo(r2wrap.x, Math.floor(this.height / 2))
            .endStroke();
        this.container.addChild(inputWire2);

        const g = this.groundGraphic.container.clone(true);
        g.x = Math.floor(this.width / 2) + this.tradius - Math.floor(this.groundGraphic.width / 2);
        g.y = Math.floor(this.height / 2) + this.tradius * 2;
        this.container.addChild(g);



        const gwire = new createjs.Shape();
        gwire
            .graphics
            .setStrokeStyle(this.strokeWidth)
            .beginStroke("black")
            .moveTo(t.x + this.tradius * 2, t.y + this.tradius * 2)
            .lineTo(t.x + this.tradius * 2, Math.floor(this.height / 2) + this.tradius * 2)
            .endStroke();
        this.container.addChild(gwire);



        const outwire = new createjs.Shape();
        outwire
            .graphics
            .setStrokeStyle(this.strokeWidth)
            .beginStroke("black")
            .moveTo(Math.floor(this.width / 2) + this.tradius, Math.floor(this.height / 2) - this.tradius)
            .lineTo(Math.floor(this.width / 2) + this.tradius + this.tradius, Math.floor(this.height / 2) )
            .lineTo(this.width, Math.floor(this.height / 2) )
            .endStroke();
        this.container.addChild(outwire);

        if (this.useLights) {
            this.inputLight = new Light(this.tradius, this.strokeWidth, this.bulbSize, function() {
                const input = !THIS.input;
                THIS.setInput(input);
                THIS.stage.update()
            });

            const inLightWire = new createjs.Shape();
            inLightWire
                .graphics
                .setStrokeStyle(this.strokeWidth)
                .beginStroke("black")
                .moveTo(Math.floor(this.tradius * 0.2) + this.inputLight.radius, Math.floor(this.height / 2))
                .lineTo(Math.floor(this.tradius * 0.2) + this.inputLight.radius, Math.floor(this.height / 2) - this.inputLight.radius)
                .endStroke();
            this.container.addChild(inLightWire);

            this.inputLight.container.x = Math.floor(this.tradius * 0.2);
            this.inputLight.container.y = Math.floor(this.height / 2) - this.inputLight.radius * 2.5;
            this.container.addChild(this.inputLight.container);



            this.outputLight = new Light(this.tradius, this.strokeWidth, this.bulbSize);
            
            const outLightWire = new createjs.Shape();
            outLightWire
                .graphics
                .setStrokeStyle(this.strokeWidth)
                .beginStroke("black")
                .moveTo(this.width - this.outputLight.radius * 2 - Math.floor(this.tradius * 0.2) + this.inputLight.radius, Math.floor(this.height / 2))
                .lineTo(this.width - this.outputLight.radius * 2 - Math.floor(this.tradius * 0.2) + this.inputLight.radius, Math.floor(this.height / 2) - this.outputLight.radius)
                .endStroke();
            this.container.addChild(outLightWire);


            this.outputLight.container.x = this.width - this.outputLight.radius * 2 - Math.floor(this.tradius * 0.2);
            this.outputLight.container.y = Math.floor(this.height / 2) - this.outputLight.radius * 2.5;
            this.container.addChild(this.outputLight.container);
        }










        const dash = DASH;



        this.outline = new createjs.Shape();
        this.outline
            .graphics
            .beginStroke("gray")
            .setStrokeStyle(this.strokeWidth)
            .setStrokeDash([dash, dash], 0)
            .beginFill("rgba(255, 255, 255, 0.01")
            .drawRect(0, 0, this.width, this.height)
        this.outline.name = "outline-" + this.coverName
        this.container.addChild(this.outline);




        this.coverContainer = new createjs.Container();
        this.coverContainer.name = this.coverName + "-container";
        this.cover = new createjs.Shape();
        this.cover.name = this.coverName;
        /*const THIS = this;
        this.cover.rmCover = function() {
            THIS.removeCover()
        }*/
        this.cover.graphics
            .beginStroke("black")
            .setStrokeStyle(this.strokeWidth)
            //.setStrokeDash([dash, dash], 0)
            .beginFill(this.coverColor)
            .drawRect(0, 0, this.width, this.height)
        this.coverContainer.addChild(this.cover);


        var text = new createjs.Text("Not", this.tradius * 4 + "px Arial", "black");
        text.x = this.tradius * 3;
        text.y = this.tradius * 1;
        text.textBaseline = "alphabetic"
        text.rotation = 90
        this.coverContainer.addChild(text)


        //this.cover.on("click", function(event) { console.log("clicked"); }, null, false, null, true)
        //this.cover.on("click", function(event) { console.log("clicked"); })

        this.container.addChild(this.coverContainer)








        this.container.regX = this.width / 2;
        this.container.regY = this.width / 2;
        this.container.rotation = -90;
        const oldContainer = this.container;
        this.container = new createjs.Container();
        this.container.addChild(oldContainer);
        oldContainer.x = this.width / 2; 
        oldContainer.y = this.height / 2;



        /*const plusHorz = new createjs.Shape();
        plusHorz
            .graphics
            .setStrokeStyle(this.strokeWidth * 2)
            .beginStroke("black")
            .moveTo(this.tradius * 3, Math.floor(this.tradius / 2.5))
            .lineTo(this.tradius * 3, 0)
            .endStroke();
        this.container.addChild(plusVert);*/
    }
}

class Light {

    constructor(tradius, strokeWidth, size, func) {
        this.tradius = tradius;
        this.radius = Math.floor(this.tradius * size);
        this.strokeWidth = strokeWidth;
        this.size = size;
        this.func = func;
        this.draw();


    }

    draw() {
        this.container = new createjs.Container();
        const bulbName =  "bulb-" + (Math.random() * 99999999).toString();

        this.bulb = new createjs.Shape();
        this.bulb.name = bulbName
        this.fillCommand = this.bulb
            .graphics
            .setStrokeStyle(this.strokeWidth)
            .beginStroke("black")
            .beginFill(LIGHT_ON_COLOR)
            .command;

        this.bulb.graphics
            .drawCircle(this.radius, this.radius, this.radius);

            this.bulb.cursor = "pointer";
        if (this.func) {
            console.log("Asdf")
            const THIS = this;
            /*const scope = null;
            const once = true;
            const data = null;
            const useCapture = false;*/
            this.bulb.cursor = "pointer";
            this.bulb.addEventListener("click", function(event){
                console.log("saf")
                var objs = stage.getObjectsUnderPoint(event.stageX, event.stageY);
                if (objs.length > 0 && objs[0].name == bulbName) {
                    THIS.func();
                }
            }/*, scope, once, data, useCapture*/);

        }

        this.container.addChild(this.bulb);

    }
}

class GroundGraphic {

    constructor(tradius, strokeWidth) {
        this.tradius = tradius;
        this.strokeWidth = strokeWidth;
        this.draw();
    }

    draw() {
        const stepwidth = Math.floor(this.tradius / 7);
        const gapheight = Math.floor(this.tradius / 7);

        this.stepwidth = stepwidth;
        this.gapheight = gapheight;
        this.width = stepwidth * 6;
        this.height = gapheight * 3;
        this.centerx = Math.floor(this.width / 2);
        const centerx = this.centerx

        this.container = new createjs.Container();


        /*const dash = DASH;
        const outline = new createjs.Shape();
        outline
            .graphics
            .beginStroke("gray")
            .setStrokeStyle(this.strokeWidth)
            .setStrokeDash([dash, dash], 0)
            .drawRect(0, 0, this.width, this.height);
        this.container.addChild(outline);*/
        


        const z1 = new createjs.Shape();
        z1
            .graphics
            .setStrokeStyle(this.strokeWidth)
            .beginStroke("black")
            .moveTo(0, 0)
            .lineTo(this.width, 0)
            .endStroke();
        this.container.addChild(z1);

        const z2 = new createjs.Shape();
        z2
            .graphics
            .setStrokeStyle(this.strokeWidth)
            .beginStroke("black")
            .moveTo(this.stepwidth, this.gapheight)
            .lineTo(this.width - this.stepwidth, this.gapheight)
            .endStroke();
        this.container.addChild(z2);

        const z3 = new createjs.Shape();
        z3
            .graphics
            .setStrokeStyle(this.strokeWidth)
            .beginStroke("black")
            .moveTo(this.stepwidth * 2 , this.gapheight * 2)
            .lineTo(this.width - this.stepwidth * 2, this.gapheight * 2)
            .endStroke();
        this.container.addChild(z3);
    }
}

class ResistorGraphic {

    constructor(tradius, strokeWidth) {
        this.tradius = tradius;
        this.strokeWidth = strokeWidth;
        this.draw();
    }

    draw() {
        const stepwidth = Math.floor(this.tradius / 4);
        const step = Math.floor(this.tradius * 2 / 15);
        const centerx = stepwidth;

        this.stepwidth = stepwidth;
        this.step = step;
        this.centerx = centerx;
        this.width = stepwidth * 2;
        this.height = step * 12;

        this.container = new createjs.Container();
       
        /*const dash = DASH;
        const outline = new createjs.Shape();
        outline
            .graphics
            .beginStroke("gray")
            .setStrokeStyle(this.strokeWidth)
            .setStrokeDash([dash, dash], 0)
            .drawRect(0, 0, this.width, this.height);
        this.container.addChild(outline);
        */



        const zig = new createjs.Shape();
        zig
            .graphics
            .setStrokeStyle(this.strokeWidth)
            .beginStroke("black")
            .moveTo(centerx, 0)
            .lineTo(centerx - stepwidth, step * 1)
            .lineTo(centerx + stepwidth, step * 3)
            .lineTo(centerx - stepwidth, step * 5)
            .lineTo(centerx + stepwidth, step * 7)
            .lineTo(centerx - stepwidth, step * 9)
            .lineTo(centerx + stepwidth, step * 11)
            .lineTo(centerx, step * 12)
            .endStroke();
        this.container.addChild(zig);
    }
}

class TransistorGraphic {

    // Absolute x y coordinates
    constructor(tradius, strokeWidth) {
        this.x = 0;
        this.y = 0;
        this.tradius = tradius;
        this.strokeWidth = strokeWidth;
        this.width = this.tradius * 2;
        this.height = this.tradius * 2;
        this.draw();
    }

    draw() {

        const TRADIUS = this.tradius;

        this.container = new createjs.Container();

        const circle = new createjs.Shape();
        circle
            .graphics
            .setStrokeStyle(this.strokeWidth)
            .beginStroke("black")
            .drawCircle(this.tradius, this.tradius, this.tradius);
        circle.x = this.x;
        circle.y = this.y;
        this.container.addChild(circle);

        const bar = new createjs.Shape();
        bar
            .graphics
            .setStrokeStyle(this.strokeWidth)
            .beginStroke("black")
            .moveTo(this.x + Math.floor(TRADIUS / 1.7), this.y + Math.floor(TRADIUS / 1.7))
            .lineTo(this.x + Math.floor(TRADIUS / 1.7), this.y + Math.floor(TRADIUS / 1.7 * 2.5))
            .endStroke();
        this.container.addChild(bar);

        const left = new createjs.Shape();
        left
            .graphics
            .setStrokeStyle(this.strokeWidth)
            .beginStroke("black")
            .moveTo(this.x, this.y + TRADIUS)
            .lineTo(this.x + Math.floor(TRADIUS / 1.7), this.y + TRADIUS)
            .endStroke();
        this.container.addChild(left);

        const top = new createjs.Shape();
        top
            .graphics
            .setStrokeStyle(this.strokeWidth)
            .beginStroke("black")
            .moveTo(this.x + Math.floor(TRADIUS / 1.7), this.y + Math.floor(TRADIUS / 1.7) + Math.floor(TRADIUS / 5))
            .lineTo(this.x + TRADIUS * 2, this.y)
            .endStroke();
        this.container.addChild(top);

        const bottom = new createjs.Shape();
        bottom
            .graphics
            .setStrokeStyle(this.strokeWidth)
            .beginStroke("black")
            .moveTo(this.x +  Math.floor(TRADIUS / 1.7), this.y + TRADIUS * 2 - (Math.floor(TRADIUS / 1.7) + Math.floor(TRADIUS / 5)))
            .lineTo(this.x + TRADIUS * 2, this.y + TRADIUS * 2)
            .endStroke();
        this.container.addChild(bottom);

        const arrow = new createjs.Shape();
        const size = TRADIUS / 3;
        const sides = 3;
        const angle = 30;
        arrow.graphics.beginFill("black").drawPolyStar(this.x + TRADIUS * 1.3, this.y + TRADIUS * 1.6, size, sides, 0, angle);
        this.container.addChild(arrow);

        /*const clone = this.container.clone(true);
        clone.x = 100;
        clone.y = 100;

        stage.addChild(this.container);
        stage.addChild(clone);

        this.container.x = 50;
        this.container.y = 50;*/
    }
}

class Circuit {
  constructor(width, height, canvasId, tradius, strokeWidth) {
    this.width = width;
    this.height = height;
    this.canvasId = canvasId;
    this.tradius = tradius;
    this.strokeWidth = strokeWidth;
    this.stage = new createjs.Stage(canvasId);

    this.transistorGraphic = new TransistorGraphic(this.tradius, this.strokeWidth);
    this.resistorGraphic = new ResistorGraphic(this.tradius, this.strokeWidth);
    this.groundGraphic = new GroundGraphic(this.tradius, this.strokeWidth);

    //this.stage.scale = 1/2;
  }

  /*addItem(item) {
    item.draw(this.strokeWidth);
  }*/
}

class FourBitAdder {
    setInput(y8, y4, y2, y1, x8, x4, x2, x1) {
        this.inputY8 = y8;
        this.inputY4 = y4;
        this.inputY2 = y2;
        this.inputY1 = y1;
        this.inputX8 = x8;
        this.inputX4 = x4;
        this.inputX2 = x2;
        this.inputX1 = x1;

        this.adder1.setInput(this.inputY1, this.inputX1, false);
        this.adder2.setInput(this.inputY2, this.inputX2, this.adder1.outputC);
        this.adder4 .setInput(this.inputY4, this.inputX8, this.adder2.outputC);
        this.adder8.setInput(this.inputY8, this.inputX8, this.adder4.outputC);

        this.outputZ1 = this.adder1.outputZ;
        this.outputZ2 = this.adder2.outputZ;
        this.outputZ4 = this.adder4.outputZ;
        this.outputZ8 = this.adder8.outputZ;
        this.outputZ16 = this.adder1.outputC;

        if (this.inputY1) {
            this.y1lightBig.fillCommand.style = LIGHT_ON_COLOR;
        } else {
            this.y1lightBig.fillCommand.style = LIGHT_OFF_COLOR;
        }

        if (this.inputX1) {
            this.x1lightBig.fillCommand.style = LIGHT_ON_COLOR;
        } else {
            this.x1lightBig.fillCommand.style = LIGHT_OFF_COLOR;
        }

        if (this.inputY2) {
            this.y2lightBig.fillCommand.style = LIGHT_ON_COLOR;
        } else {
            this.y2lightBig.fillCommand.style = LIGHT_OFF_COLOR;
        }

        if (this.inputX2) {
            this.x2lightBig.fillCommand.style = LIGHT_ON_COLOR;
        } else {
            this.x2lightBig.fillCommand.style = LIGHT_OFF_COLOR;
        }

        if (this.inputY4) {
            this.y4lightBig.fillCommand.style = LIGHT_ON_COLOR;
        } else {
            this.y4lightBig.fillCommand.style = LIGHT_OFF_COLOR;
        }

        if (this.inputX4) {
            this.x4lightBig.fillCommand.style = LIGHT_ON_COLOR;
        } else {
            this.x4lightBig.fillCommand.style = LIGHT_OFF_COLOR;
        }
        
        if (this.inputY8) {
            this.y8lightBig.fillCommand.style = LIGHT_ON_COLOR;
        } else {
            this.y8lightBig.fillCommand.style = LIGHT_OFF_COLOR;
        }

        if (this.inputX8) {
            this.x8lightBig.fillCommand.style = LIGHT_ON_COLOR;
        } else {
            this.x8lightBig.fillCommand.style = LIGHT_OFF_COLOR;
        }
        

        if (this.outputZ1) {
            this.z1lightBig.fillCommand.style = LIGHT_ON_COLOR;
        } else {
            this.z1lightBig.fillCommand.style = LIGHT_OFF_COLOR;
        }
        





    }

    constructor(stage, tradius, fourBitAdderStrokeWidth, fullAdderStrokeWidth, halfAdderStrokeWidth, primStrokeWidth, subStrokeWidth) {
        const THIS = this;
        this.stage = stage;
        this.coverColor = "#d7bde2";
        this.coverName = "cover-" + (Math.random() * 99999999).toString();
        this.tradius = tradius

        this.inputY8 = false;
        this.inputY4 = false;
        this.inputY2 = false;
        this.inputY1 = false;
        this.inputX8 = false;
        this.inputX4 = false;
        this.inputX2 = false;
        this.inputX1 = false;

        this.output16 = false;
        this.output8 = false;
        this.output4 = false;
        this.output2 = false;
        this.output1 = false;

        this.bulbSize = FOUR_BIT_ADDER_BULB_SIZE;
        this.bigBulbSize = FOUR_BIT_ADDER_BULB_SIZE * 4;
        this.fourBitAdderStrokeWidth = fourBitAdderStrokeWidth
        this.fullAdderStrokeWidth = fullAdderStrokeWidth;
        this.halfAdderStrokeWidth = halfAdderStrokeWidth;
        this.primStrokeWidth = primStrokeWidth;
        this.strokeWidth = subStrokeWidth;


        this.transistorGraphic = new TransistorGraphic(this.tradius, this.strokeWidth);
        this.resistorGraphic = new ResistorGraphic(this.tradius, this.strokeWidth);
        this.groundGraphic = new GroundGraphic(this.tradius, this.strokeWidth);

        this.container = new createjs.Container();

        const interAdderSpan = this.bulbSize * this.tradius * 6;

        this.adder8 = new FullAdder(this.stage, this.tradius, this.fullAdderStrokeWidth, this.halfAdderStrokeWidth, this.primStrokeWidth, this.strokeWidth);
        const a8 = this.adder8.container;
        a8.x = interAdderSpan;
        a8.y = interAdderSpan;
        this.container.addChild(a8);

        this.adder4 = new FullAdder(this.stage, this.tradius, this.fullAdderStrokeWidth, this.halfAdderStrokeWidth, this.primStrokeWidth, this.strokeWidth);
        const a4 = this.adder4.container;
        a4.x = a8.x + this.adder8.width + interAdderSpan;
        a4.y = a8.y;
        this.container.addChild(a4);

        this.adder2 = new FullAdder(this.stage, this.tradius, this.fullAdderStrokeWidth, this.halfAdderStrokeWidth, this.primStrokeWidth, this.strokeWidth);
        const a2 = this.adder2.container;
        a2.x = a4.x + this.adder4.width + interAdderSpan;
        a2.y = a8.y;
        this.container.addChild(a2);

        this.adder1 = new FullAdder(this.stage, this.tradius, this.fullAdderStrokeWidth, this.halfAdderStrokeWidth, this.primStrokeWidth, this.strokeWidth);
        const a1 = this.adder1.container;
        a1.x = a2.x + this.adder2.width + interAdderSpan;
        a1.y = a8.y;
        this.container.addChild(a1);


        this.width = a1.x + this.adder1.width +  interAdderSpan; 
        this.height = a4.y + this.adder4.height + interAdderSpan;










        const y8wire = new createjs.Shape();
        y8wire
            .graphics
            .setStrokeStyle(this.fourBitAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(a8.x + this.adder8.inLeftX, a8.y + this.adder8.height)
            .lineTo(a8.x + this.adder8.inLeftX, this.height + interAdderSpan)
            .endStroke();
        this.container.addChild(y8wire);

        this.y8lightBig = new Light(this.tradius, this.fourBitAdderStrokeWidth, this.bigBulbSize, function(){
            THIS.setInput(!THIS.inputY8, THIS.inputY4, THIS.inputY2, THIS.inputY1, THIS.inputX8, THIS.inputX4, THIS.inputX2, THIS.inputX1);
            THIS.stage.update();
        });
        this.y8lightBig.container.x = a8.x + this.adder8.inLeftX - this.bigBulbSize * this.tradius;
        this.y8lightBig.container.y = this.height + interAdderSpan;
        this.container.addChild(this.y8lightBig.container);


        const x8wire = new createjs.Shape();
        x8wire
            .graphics
            .setStrokeStyle(this.fourBitAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(a8.x + this.adder8.inRightX, a8.y + this.adder8.height)
            .lineTo(a8.x + this.adder8.inRightX, this.height + interAdderSpan + this.bigBulbSize * this.tradius * 3)
            .endStroke();
        this.container.addChild(x8wire);

        this.x8lightBig = new Light(this.tradius, this.fourBitAdderStrokeWidth, this.bigBulbSize, function(){
            THIS.setInput(THIS.inputY8, THIS.inputY4, THIS.inputY2, THIS.inputY1, !THIS.inputX8, THIS.inputX4, THIS.inputX2, THIS.inputX1);
            THIS.stage.update();
        });
        this.x8lightBig.container.x = a8.x + this.adder8.inRightX - this.bigBulbSize * this.tradius;
        this.x8lightBig.container.y = this.height + interAdderSpan + this.bigBulbSize * this.tradius * 3;
        this.container.addChild(this.x8lightBig.container);






        const y4wire = new createjs.Shape();
        y4wire
            .graphics
            .setStrokeStyle(this.fourBitAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(a4.x + this.adder4.inLeftX, a4.y + this.adder4.height)
            .lineTo(a4.x + this.adder4.inLeftX, this.height + interAdderSpan)
            .endStroke();
        this.container.addChild(y4wire);

        this.y4lightBig = new Light(this.tradius, this.fourBitAdderStrokeWidth, this.bigBulbSize, function(){
            THIS.setInput(THIS.inputY8, !THIS.inputY4, THIS.inputY2, THIS.inputY1, THIS.inputX8, THIS.inputX4, THIS.inputX2, THIS.inputX1);
            THIS.stage.update();
        });
        this.y4lightBig.container.x = a4.x + this.adder4.inLeftX - this.bigBulbSize * this.tradius;
        this.y4lightBig.container.y = this.height + interAdderSpan;
        this.container.addChild(this.y4lightBig.container);


        const x4wire = new createjs.Shape();
        x4wire
            .graphics
            .setStrokeStyle(this.fourBitAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(a4.x + this.adder4.inRightX, a4.y + this.adder4.height)
            .lineTo(a4.x + this.adder4.inRightX, this.height + interAdderSpan + this.bigBulbSize * this.tradius * 3)
            .endStroke();
        this.container.addChild(x4wire);

        this.x4lightBig = new Light(this.tradius, this.fourBitAdderStrokeWidth, this.bigBulbSize, function(){
            THIS.setInput(THIS.inputY8, THIS.inputY4, THIS.inputY2, THIS.inputY1, THIS.inputX8, !THIS.inputX4, THIS.inputX2, THIS.inputX1);
            THIS.stage.update();
        });
        this.x4lightBig.container.x = a4.x + this.adder4.inRightX - this.bigBulbSize * this.tradius;
        this.x4lightBig.container.y = this.height + interAdderSpan + this.bigBulbSize * this.tradius * 3;
        this.container.addChild(this.x4lightBig.container);









        const y2wire = new createjs.Shape();
        y2wire
            .graphics
            .setStrokeStyle(this.fourBitAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(a2.x + this.adder2.inLeftX, a2.y + this.adder2.height)
            .lineTo(a2.x + this.adder2.inLeftX, this.height + interAdderSpan)
            .endStroke();
        this.container.addChild(y2wire);

        this.y2lightBig = new Light(this.tradius, this.fourBitAdderStrokeWidth, this.bigBulbSize, function(){
            THIS.setInput(THIS.inputY8, THIS.inputY4, !THIS.inputY2, THIS.inputY1, THIS.inputX8, THIS.inputX4, THIS.inputX2, THIS.inputX1);
            THIS.stage.update();
        });
        this.y2lightBig.container.x = a2.x + this.adder2.inLeftX - this.bigBulbSize * this.tradius;
        this.y2lightBig.container.y = this.height + interAdderSpan;
        this.container.addChild(this.y2lightBig.container);


        const x2wire = new createjs.Shape();
        x2wire
            .graphics
            .setStrokeStyle(this.fourBitAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(a2.x + this.adder2.inRightX, a2.y + this.adder2.height)
            .lineTo(a2.x + this.adder2.inRightX, this.height + interAdderSpan + this.bigBulbSize * this.tradius * 3)
            .endStroke();
        this.container.addChild(x2wire);

        this.x2lightBig = new Light(this.tradius, this.fourBitAdderStrokeWidth, this.bigBulbSize, function(){
            THIS.setInput(THIS.inputY8, THIS.inputY4, THIS.inputY2, THIS.inputY1, THIS.inputX8, THIS.inputX4, !THIS.inputX2, THIS.inputX1);
            THIS.stage.update();
        });
        this.x2lightBig.container.x = a2.x + this.adder2.inRightX - this.bigBulbSize * this.tradius;
        this.x2lightBig.container.y = this.height + interAdderSpan + this.bigBulbSize * this.tradius * 3;
        this.container.addChild(this.x2lightBig.container);




        const y1wire = new createjs.Shape();
        y1wire
            .graphics
            .setStrokeStyle(this.fourBitAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(a1.x + this.adder1.inLeftX, a1.y + this.adder1.height)
            .lineTo(a1.x + this.adder1.inLeftX, this.height + interAdderSpan)
            .endStroke();
        this.container.addChild(y1wire);

        this.y1lightBig = new Light(this.tradius, this.fourBitAdderStrokeWidth, this.bigBulbSize, function(){
            THIS.setInput(THIS.inputY8, THIS.inputY4, THIS.inputY2, !THIS.inputY1, THIS.inputX8, THIS.inputX4, THIS.inputX2, THIS.inputX1);
            THIS.stage.update();
        });
        this.y1lightBig.container.x = a1.x + this.adder1.inLeftX - this.bigBulbSize * this.tradius;
        this.y1lightBig.container.y = this.height + interAdderSpan;
        this.container.addChild(this.y1lightBig.container);


        const x1wire = new createjs.Shape();
        x1wire
            .graphics
            .setStrokeStyle(this.fourBitAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(a1.x + this.adder1.inRightX, a1.y + this.adder1.height)
            .lineTo(a1.x + this.adder1.inRightX, this.height + interAdderSpan + this.bigBulbSize * this.tradius * 3)
            .endStroke();
        this.container.addChild(x1wire);

        this.x1lightBig = new Light(this.tradius, this.fourBitAdderStrokeWidth, this.bigBulbSize, function(){
            THIS.setInput(THIS.inputY8, THIS.inputY4, THIS.inputY2, THIS.inputY1, THIS.inputX8, THIS.inputX4, THIS.inputX2, !THIS.inputX1);
            THIS.stage.update();
        });
        this.x1lightBig.container.x = a1.x + this.adder1.inRightX - this.bigBulbSize * this.tradius;
        this.x1lightBig.container.y = this.height + interAdderSpan + this.bigBulbSize * this.tradius * 3;
        this.container.addChild(this.x1lightBig.container);








        const z8wire = new createjs.Shape();
        z8wire
            .graphics
            .setStrokeStyle(this.fourBitAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(a8.x + Math.floor(this.adder8.width / 2), a8.y)
            .lineTo(a8.x + Math.floor(this.adder8.width / 2), a8.y - interAdderSpan - this.bigBulbSize * this.tradius * 2)
            .endStroke();
        this.container.addChild(z8wire);

        this.z8lightBig = new Light(this.tradius, this.fourBitAdderStrokeWidth, this.bigBulbSize);
        this.z8lightBig.container.x = a8.x + Math.floor(this.adder8.width / 2) - this.bigBulbSize * this.tradius;
        this.z8lightBig.container.y = a8.y - interAdderSpan - this.bigBulbSize * this.tradius * 4;
        this.container.addChild(this.z8lightBig.container);


        const z4wire = new createjs.Shape();
        z4wire
            .graphics
            .setStrokeStyle(this.fourBitAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(a4.x + Math.floor(this.adder4.width / 2), a4.y)
            .lineTo(a4.x + Math.floor(this.adder4.width / 2), a4.y - interAdderSpan - this.bigBulbSize * this.tradius * 2)
            .endStroke();
        this.container.addChild(z4wire);

        this.z4lightBig = new Light(this.tradius, this.fourBitAdderStrokeWidth, this.bigBulbSize);
        this.z4lightBig.container.x = a4.x + Math.floor(this.adder4.width / 2) - this.bigBulbSize * this.tradius;
        this.z4lightBig.container.y = a4.y - interAdderSpan - this.bigBulbSize * this.tradius * 4;
        this.container.addChild(this.z4lightBig.container);


        const z2wire = new createjs.Shape();
        z2wire
            .graphics
            .setStrokeStyle(this.fourBitAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(a2.x + Math.floor(this.adder2.width / 2), a2.y)
            .lineTo(a2.x + Math.floor(this.adder2.width / 2), a2.y - interAdderSpan - this.bigBulbSize * this.tradius * 2)
            .endStroke();
        this.container.addChild(z2wire);

        this.z2lightBig = new Light(this.tradius, this.fourBitAdderStrokeWidth, this.bigBulbSize);
        this.z2lightBig.container.x = a2.x + Math.floor(this.adder2.width / 2) - this.bigBulbSize * this.tradius;
        this.z2lightBig.container.y = a2.y - interAdderSpan - this.bigBulbSize * this.tradius * 4;
        this.container.addChild(this.z2lightBig.container);


        const z1wire = new createjs.Shape();
        z1wire
            .graphics
            .setStrokeStyle(this.fourBitAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(a1.x + Math.floor(this.adder1.width / 2), a1.y)
            .lineTo(a1.x + Math.floor(this.adder1.width / 2), a1.y - interAdderSpan - this.bigBulbSize * this.tradius * 2)
            .endStroke();
        this.container.addChild(z1wire);

        this.z1lightBig = new Light(this.tradius, this.fourBitAdderStrokeWidth, this.bigBulbSize);
        this.z1lightBig.container.x = a1.x + Math.floor(this.adder1.width / 2) - this.bigBulbSize * this.tradius;
        this.z1lightBig.container.y = a1.y - interAdderSpan - this.bigBulbSize * this.tradius * 4;
        this.container.addChild(this.z1lightBig.container);

























        const dash = 80;

        this.outline = new createjs.Shape();
        this.outline
            .graphics
            .beginStroke("gray")
            .setStrokeStyle(this.fourBitAdderStrokeWidth)
            .setStrokeDash([dash, dash], 0)
            .beginFill("rgba(255, 255, 255, 0.01")
            .drawRect(0, 0, this.width, this.height)
        this.outline.name = "outline-" + this.coverName
        this.container.addChild(this.outline);




        this.coverContainer = new createjs.Container();
        this.coverContainer.name = this.coverName + "-container";
        this.cover = new createjs.Shape();
        this.cover.name = this.coverName;
        this.cover.graphics
            .beginStroke("black")
            .setStrokeStyle(this.fourBitAdderStrokeWidth)
            //.setStrokeDash([dash, dash], 0)
            .beginFill(this.coverColor)
            .drawRect(0, 0, this.width, this.height)
        this.coverContainer.addChild(this.cover);


        var text = new createjs.Text("Computer", this.tradius * 30 + "px Arial", "black");
        text.x = this.tradius * 27;
        text.y = this.tradius * 110;
        text.textBaseline = "alphabetic"
        //text.rotation = 90
        this.coverContainer.addChild(text)


        //this.cover.on("click", function(event) { console.log("clicked"); }, null, false, null, true)
        //this.cover.on("click", function(event) { console.log("clicked"); })

        this.container.addChild(this.coverContainer)







        this.setInput(this.input1, this.input2);

    }
}

class FullAdder {
    setInput(y, x, c) {
        this.inputY = y;
        this.inputX = x;
        this.inputC = c;

        this.leftHalf.setInput(this.inputY, this.inputX);
        this.rightHalf.setInput(this.leftHalf.output2, this.inputC);
        this.orGate.setInput(this.leftHalf.output1, this.rightHalf.output1);

        this.outputC = this.orGate.getOutput();
        this.outputZ = this.rightHalf.output2;

        if (this.inputY) {
            this.yinLight.fillCommand.style = LIGHT_ON_COLOR;
        } else {
            this.yinLight.fillCommand.style = LIGHT_OFF_COLOR;
        }

        if (this.inputX) {
            this.xinLight.fillCommand.style = LIGHT_ON_COLOR;
        } else {
            this.xinLight.fillCommand.style = LIGHT_OFF_COLOR;
        }

        if (this.inputC) {
            this.cinLight.fillCommand.style = LIGHT_ON_COLOR;
        } else {
            this.cinLight.fillCommand.style = LIGHT_OFF_COLOR;
        }

        if (this.leftHalf.output2) {
            this.inoutLight.fillCommand.style = LIGHT_ON_COLOR;
        } else {
            this.inoutLight.fillCommand.style = LIGHT_OFF_COLOR;
        }

        if (this.leftHalf.output1) {
            this.orInLeftLight.fillCommand.style = LIGHT_ON_COLOR;
        } else {
            this.orInLeftLight.fillCommand.style = LIGHT_OFF_COLOR;
        }

        if (this.rightHalf.output1) {
            this.orInRightLight.fillCommand.style = LIGHT_ON_COLOR;
        } else {
            this.orInRightLight.fillCommand.style = LIGHT_OFF_COLOR;
        }

        if (this.orGate.getOutput()) {
            this.orOutLight.fillCommand.style = LIGHT_ON_COLOR;
        } else {
            this.orOutLight.fillCommand.style = LIGHT_OFF_COLOR;
        }

        if (this.rightHalf.output2) {
            this.zOutLight.fillCommand.style = LIGHT_ON_COLOR;
        } else {
            this.zOutLight.fillCommand.style = LIGHT_OFF_COLOR;
        }



    }

    constructor(stage, tradius, fullAdderStrokeWidth, halfAdderStrokeWidth, primStrokeWidth, subStrokeWidth) {
        const THIS = this;
        this.stage = stage;
        this.coverColor = "#9cf7ef";
        this.coverName = "cover-" + (Math.random() * 99999999).toString();
        this.tradius = tradius

        this.input1 = false;
        this.input2 = false;
        this.output1 = false;
        this.output2 = false;

        this.bulbSize = FULL_ADDER_BULB_SIZE;
        this.fullAdderStrokeWidth = fullAdderStrokeWidth;
        this.halfAdderStrokeWidth = halfAdderStrokeWidth;
        this.primStrokeWidth = primStrokeWidth;
        this.strokeWidth = subStrokeWidth;

        this.transistorGraphic = new TransistorGraphic(this.tradius, this.strokeWidth);
        this.resistorGraphic = new ResistorGraphic(this.tradius, this.strokeWidth);
        this.groundGraphic = new GroundGraphic(this.tradius, this.strokeWidth);

        this.container = new createjs.Container();




        this.rightHalf = new HalfAdder(this.stage, this.tradius, this.halfAdderStrokeWidth, this.primStrokeWidth, this.strokeWidth);
        const rh = this.rightHalf.container;
        rh.x = this.tradius * 53;
        rh.y = this.bulbSize * 16 * this.tradius;
        this.container.addChild(rh);


        this.leftHalf = new HalfAdder(this.stage, this.tradius, this.halfAdderStrokeWidth, this.primStrokeWidth, this.strokeWidth);
        const lh = this.leftHalf.container;
        lh.x = this.bulbSize * this.tradius * 6; 
        lh.y = rh.y + this.rightHalf.height + this.bulbSize * 4 * this.tradius;
        this.container.addChild(lh);

        this.orGate = new OrGate(this.stage, this.tradius, this.strokeWidth, this.transistorGraphic, this.resistorGraphic, this.groundGraphic, true);
        const og = this.orGate.container;
        og.x = this.tradius * 32;
        og.y = this.bulbSize * 6 * this.tradius;
        this.container.addChild(og);











        this.width = rh.x + this.rightHalf.width +  this.bulbSize * this.tradius * 6; 
        this.height = lh.y + this.leftHalf.height + this.bulbSize * 8 * this.tradius;





        const inoutwire = new createjs.Shape();
        inoutwire
            .graphics
            .setStrokeStyle(this.fullAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(lh.x + this.leftHalf.inRightX,lh.y)
            .lineTo(rh.x + this.rightHalf.inLeftX, rh.y + this.rightHalf.height)
            .endStroke();
        this.container.addChild(inoutwire);



        const inoutwireBulb = new createjs.Shape();
        inoutwireBulb
            .graphics
            .setStrokeStyle(this.fullAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(lh.x + this.leftHalf.inRightX , lh.y - this.bulbSize * this.tradius * 2)
            .lineTo(lh.x + this.leftHalf.inRightX + this.bulbSize * this.tradius, lh.y - this.bulbSize * this.tradius * 2)
            .endStroke();
        this.container.addChild(inoutwireBulb);


        this.inoutLight = new Light(this.tradius, this.fullAdderStrokeWidth, this.bulbSize);
        this.inoutLight.container.x = lh.x + this.leftHalf.inRightX + this.bulbSize * this.tradius ;
        this.inoutLight.container.y = lh.y - this.bulbSize * this.tradius * 3;
        this.container.addChild(this.inoutLight.container);



        const orInLeftWire = new createjs.Shape();
        orInLeftWire
            .graphics
            .setStrokeStyle(this.fullAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(lh.x + this.leftHalf.inLeftX,lh.y)
            .lineTo(og.x + this.orGate.inLeftX, og.y + this.orGate.width)
            .endStroke();
        this.container.addChild(orInLeftWire);



        const orOutWire1 = new createjs.Shape();
        orOutWire1
            .graphics
            .setStrokeStyle(this.fullAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(og.x + Math.floor(this.orGate.height / 2), og.y)
            .lineTo(og.x + Math.floor(this.orGate.height / 2), og.y - this.bulbSize * this.tradius * 3)
            .lineTo(og.x - this.bulbSize * this.tradius * 3, og.y - this.bulbSize * this.tradius * 3)
            .lineTo(og.x - this.bulbSize * this.tradius * 3, Math.floor(this.height / 2))
            .lineTo(0, Math.floor(this.height / 2))
            .endStroke();
        this.container.addChild(orOutWire1);

        const orInLeftWireBulb = new createjs.Shape();
        orInLeftWireBulb
            .graphics
            .setStrokeStyle(this.fullAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(og.x - Math.floor(this.orGate.height / 2), og.y + this.orGate.width * 2)
            .lineTo(og.x + this.orGate.inLeftX, og.y + this.orGate.width * 2)
            .endStroke();
        this.container.addChild(orInLeftWireBulb);

        this.orInLeftLight = new Light(this.tradius, this.fullAdderStrokeWidth, this.bulbSize);
        this.orInLeftLight.container.x = og.x - Math.floor(this.orGate.height / 2);
        this.orInLeftLight.container.y = og.y + this.orGate.width * 1.5;
        this.container.addChild(this.orInLeftLight.container);


        const orInRightWire1 = new createjs.Shape();
        orInRightWire1
            .graphics
            .setStrokeStyle(this.fullAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(og.x + this.orGate.inRightX, og.y + this.orGate.width)
            .lineTo(og.x + this.orGate.inRightX, og.y + this.orGate.width + this.bulbSize * this.tradius * 5)
            .lineTo(rh.x + this.rightHalf.inLeftX, og.y + this.orGate.width + this.bulbSize * this.tradius * 5)
            .lineTo(rh.x + this.rightHalf.inLeftX, rh.y)
            .endStroke();
        this.container.addChild(orInRightWire1);


        const orInRightWireBulb = new createjs.Shape();
        orInRightWireBulb
            .graphics
            .setStrokeStyle(this.fullAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(og.x + Math.floor(this.orGate.height), og.y + this.orGate.width * 2)
            .lineTo(og.x + this.orGate.inRightX, og.y + this.orGate.width * 2)
            .endStroke();
        this.container.addChild(orInRightWireBulb);


        this.orInRightLight = new Light(this.tradius, this.fullAdderStrokeWidth, this.bulbSize);
        this.orInRightLight.container.x = og.x + Math.floor(this.orGate.height);
        this.orInRightLight.container.y = og.y + this.orGate.width * 1.5;
        this.container.addChild(this.orInRightLight.container);



        const orOutWireBulb = new createjs.Shape();
        orOutWireBulb
            .graphics
            .setStrokeStyle(this.fullAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(og.x + this.bulbSize * this.tradius * 2, og.y - Math.floor(this.orGate.height / 2))
            .lineTo(og.x + this.bulbSize * this.tradius * 3, og.y - Math.floor(this.orGate.height / 2))
            .endStroke();
        this.container.addChild(orOutWireBulb);


        this.orOutLight = new Light(this.tradius, this.fullAdderStrokeWidth, this.bulbSize);
        this.orOutLight.container.x = og.x + Math.floor(this.orGate.height / 2) + this.bulbSize * this.tradius ;
        this.orOutLight.container.y = og.y - this.bulbSize * this.tradius * 3;
        this.container.addChild(this.orOutLight.container);






        const zoutWire = new createjs.Shape();
        zoutWire
            .graphics
            .setStrokeStyle(this.fullAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(rh.x + this.rightHalf.inRightX, rh.y)
            .lineTo(rh.x + this.rightHalf.inRightX, rh.y - this.bulbSize * this.tradius * 3)
            .lineTo(Math.floor(this.width / 2),0)
            .endStroke();
        this.container.addChild(zoutWire);


        const zOutWireBulb = new createjs.Shape();
        zOutWireBulb
            .graphics
            .setStrokeStyle(this.fullAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(rh.x +this.rightHalf.inRightX , rh.y - this.bulbSize * this.tradius * 2)
            .lineTo(rh.x +this.rightHalf.inRightX + this.bulbSize * this.tradius * 2, rh.y - this.bulbSize * this.tradius * 2)
            .endStroke();
        this.container.addChild(zOutWireBulb);


        this.zOutLight = new Light(this.tradius, this.fullAdderStrokeWidth, this.bulbSize);
        this.zOutLight.container.x = rh.x +this.rightHalf.inRightX + this.bulbSize * this.tradius ;
        this.zOutLight.container.y = rh.y - this.bulbSize * this.tradius * 3;
        this.container.addChild(this.zOutLight.container);






        const cinWire = new createjs.Shape();
        cinWire
            .graphics
            .setStrokeStyle(this.fullAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(this.width, Math.floor(this.height / 2))
            .lineTo(this.width - this.bulbSize * this.tradius * 3, Math.floor(this.height / 2))
            .lineTo(this.width - this.bulbSize * this.tradius * 3, Math.floor(this.height / 2) + this.bulbSize * this.tradius * 8)
            .lineTo(rh.x + this.rightHalf.inRightX , Math.floor(this.height / 2) + this.bulbSize * this.tradius * 8)
            .lineTo(rh.x + this.rightHalf.inRightX , rh.y + this.rightHalf.height)
            .endStroke();
        this.container.addChild(cinWire);









        const cinwireBulb = new createjs.Shape();
        cinwireBulb
            .graphics
            .setStrokeStyle(this.fullAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(rh.x + this.rightHalf.inRightX , lh.y - this.bulbSize * this.tradius * 2)
            .lineTo(rh.x + this.rightHalf.inRightX + this.bulbSize * this.tradius, lh.y - this.bulbSize * this.tradius * 2)
            .endStroke();
        this.container.addChild(cinwireBulb);


        this.cinLight = new Light(this.tradius, this.fullAdderStrokeWidth, this.bulbSize, function(){
            THIS.setInput(THIS.inputY, THIS.inputX, !THIS.inputC);
            THIS.stage.update();
        });
        this.cinLight.container.x = rh.x + this.rightHalf.inRightX + this.bulbSize * this.tradius ;
        this.cinLight.container.y = lh.y - this.bulbSize * this.tradius * 3;
        this.container.addChild(this.cinLight.container);





        this.inLeftX = Math.floor(this.width / 3);
        this.inRightX = Math.floor(this.width / 3 * 2);


        const yinWire = new createjs.Shape();
        yinWire
            .graphics
            .setStrokeStyle(this.fullAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(this.inLeftX, this.height)
            .lineTo(lh.x + this.leftHalf.inLeftX, this.height - this.bulbSize * this.tradius)
            .lineTo(lh.x + this.leftHalf.inLeftX, lh.y + this.leftHalf.height)
            .endStroke();
        this.container.addChild(yinWire);

        const xinWire = new createjs.Shape();
        xinWire
            .graphics
            .setStrokeStyle(this.fullAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(this.inRightX, this.height)
            .lineTo(lh.x + this.leftHalf.inRightX, this.height - this.bulbSize * this.tradius * 3)
            .lineTo(lh.x + this.leftHalf.inRightX, lh.y + this.leftHalf.height)
            .endStroke();
        this.container.addChild(xinWire);




        const xinwireBulb = new createjs.Shape();
        xinwireBulb
            .graphics
            .setStrokeStyle(this.fullAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(lh.x + this.leftHalf.inRightX , lh.y + this.leftHalf.height + this.bulbSize * this.tradius * 2)
            .lineTo(lh.x + this.leftHalf.inRightX + this.bulbSize * this.tradius, lh.y + this.leftHalf.height + this.bulbSize * this.tradius * 2)
            .endStroke();
        this.container.addChild(xinwireBulb);


        this.xinLight = new Light(this.tradius, this.fullAdderStrokeWidth, this.bulbSize, function(){
            THIS.setInput(THIS.inputY, !THIS.inputX, THIS.inputC);
            THIS.stage.update();
        });
        this.xinLight.container.x = lh.x + this.leftHalf.inRightX + this.bulbSize * this.tradius ;
        this.xinLight.container.y = lh.y + this.leftHalf.height + this.bulbSize * this.tradius * 1;
        this.container.addChild(this.xinLight.container);


        const yinwireBulb = new createjs.Shape();
        yinwireBulb
            .graphics
            .setStrokeStyle(this.fullAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(lh.x + this.leftHalf.inLeftX , lh.y + this.leftHalf.height + this.bulbSize * this.tradius * 2)
            .lineTo(lh.x + this.leftHalf.inLeftX + this.bulbSize * this.tradius, lh.y + this.leftHalf.height + this.bulbSize * this.tradius * 2)
            .endStroke();
        this.container.addChild(yinwireBulb);


        this.yinLight = new Light(this.tradius, this.fullAdderStrokeWidth, this.bulbSize, function(){
            THIS.setInput(!THIS.inputY, THIS.inputX, THIS.inputC);
            THIS.stage.update();
        });
        this.yinLight.container.x = lh.x + this.leftHalf.inLeftX + this.bulbSize * this.tradius ;
        this.yinLight.container.y = lh.y + this.leftHalf.height + this.bulbSize * this.tradius * 1;
        this.container.addChild(this.yinLight.container);





        const dash = 40;

        this.outline = new createjs.Shape();
        this.outline
            .graphics
            .beginStroke("gray")
            .setStrokeStyle(this.fullAdderStrokeWidth)
            .setStrokeDash([dash, dash], 0)
            .beginFill("rgba(255, 255, 255, 0.01")
            .drawRect(0, 0, this.width, this.height)
        this.outline.name = "outline-" + this.coverName
        this.container.addChild(this.outline);




        this.coverContainer = new createjs.Container();
        this.coverContainer.name = this.coverName + "-container";
        this.cover = new createjs.Shape();
        this.cover.name = this.coverName;
        this.cover.graphics
            .beginStroke("black")
            .setStrokeStyle(this.fullAdderStrokeWidth)
            //.setStrokeDash([dash, dash], 0)
            .beginFill(this.coverColor)
            .drawRect(0, 0, this.width, this.height)
        this.coverContainer.addChild(this.cover);


        var text = new createjs.Text("Adder", this.tradius * 30 + "px Arial", "black");
        text.x = this.tradius * 27;
        text.y = this.tradius * 110;
        text.textBaseline = "alphabetic"
        //text.rotation = 90
        this.coverContainer.addChild(text)


        //this.cover.on("click", function(event) { console.log("clicked"); }, null, false, null, true)
        //this.cover.on("click", function(event) { console.log("clicked"); })

        this.container.addChild(this.coverContainer)







        this.setInput(this.input1, this.input2);

    }
}

class HalfAdder {

    setInput(value1, value2) {
        this.input1 = value1;
        this.input2 = value2;

        this.andGate.setInput(this.input1, this.input2);
        this.xorChip.setInput(this.input1, this.input2);
        
        this.output1 = this.andGate.getOutput();
        this.output2 = this.xorChip.getOutput();

        if (this.input1) {
            this.inLightLeft.fillCommand.style = LIGHT_ON_COLOR;
            this.xorInLightLeft.fillCommand.style = LIGHT_ON_COLOR;
        } else {
            this.inLightLeft.fillCommand.style = LIGHT_OFF_COLOR;
            this.xorInLightLeft.fillCommand.style = LIGHT_OFF_COLOR;
        }

        if (this.input2) {
            this.inLightRight.fillCommand.style = LIGHT_ON_COLOR;
            this.xorInLightRight.fillCommand.style = LIGHT_ON_COLOR;
        } else {
            this.inLightRight.fillCommand.style = LIGHT_OFF_COLOR;
            this.xorInLightRight.fillCommand.style = LIGHT_OFF_COLOR;
        }

        if (this.output1) {
            this.outLightLeft.fillCommand.style = LIGHT_ON_COLOR;
        } else {
            this.outLightLeft.fillCommand.style = LIGHT_OFF_COLOR;
        }

        if (this.output2) {
            this.outLightRight.fillCommand.style = LIGHT_ON_COLOR;
        } else {
            this.outLightRight.fillCommand.style = LIGHT_OFF_COLOR;
        }
    }

    constructor(stage, tradius, halfAdderStrokeWidth, primStrokeWidth, subStrokeWidth) {
        const THIS = this;
        this.stage = stage;
        this.coverColor = "#CBC3E3";
        this.coverName = "cover-" + (Math.random() * 99999999).toString();

        this.tradius = tradius;



        this.input1 = false;
        this.input2 = false;
        this.output1 = false;
        this.output2 = false;

        this.bulbSize = HALF_ADDER_BULB_SIZE;
        this.halfAdderStrokeWidth = halfAdderStrokeWidth;
        this.primStrokeWidth = primStrokeWidth;
        this.strokeWidth = subStrokeWidth;

        this.transistorGraphic = new TransistorGraphic(this.tradius, this.strokeWidth);
        this.resistorGraphic = new ResistorGraphic(this.tradius, this.strokeWidth);
        this.groundGraphic = new GroundGraphic(this.tradius, this.strokeWidth);

        this.container = new createjs.Container();

        this.andGate = new AndGate(this.stage, this.tradius, this.strokeWidth, this.transistorGraphic, this.resistorGraphic, this.groundGraphic, true, true);
        const ag = this.andGate.container;
        ag.x = this.bulbSize * this.tradius * 2; 
        ag.y = this.bulbSize * 3 * this.tradius;
        this.container.addChild(ag);

        this.xorChip = new XorChip(this.stage, this.tradius, this.primStrokeWidth, this.strokeWidth, true);
        const xorg = this.xorChip.container;
        xorg.x = ag.x + this.andGate.height + this.bulbSize * this.tradius; 
        xorg.y = this.bulbSize * 3 * this.tradius;
        this.container.addChild(xorg);







        this.width = xorg.x + this.xorChip.width +  this.bulbSize * this.tradius; 
        this.height = xorg.y + this.xorChip.height + this.bulbSize * 8 * this.tradius;













        const leftOutwire = new createjs.Shape();
        leftOutwire
            .graphics
            .setStrokeStyle(this.halfAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(ag.x + Math.floor(this.andGate.height /2), 0)
            .lineTo(ag.x + Math.floor(this.andGate.height /2), ag.y)
            .endStroke();
        this.container.addChild(leftOutwire);


        const leftOutwire2 = new createjs.Shape();
        leftOutwire2
            .graphics
            .setStrokeStyle(this.halfAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(ag.x + Math.floor(this.andGate.height /2), Math.floor(ag.y/2))
            .lineTo(ag.x + Math.floor(this.andGate.height /2) - this.bulbSize * this.tradius, Math.floor(ag.y/2))
            .endStroke();
        this.container.addChild(leftOutwire2);

        this.outLightLeft = new Light(this.tradius, this.halfAdderStrokeWidth, this.bulbSize);
        this.outLightLeft.container.x = ag.x + Math.floor(this.andGate.height /2) - this.bulbSize * this.tradius * 3;
        this.outLightLeft.container.y = Math.floor(ag.y/2) - this.bulbSize * this.tradius;
        this.container.addChild(this.outLightLeft.container);







        const leftInwire = new createjs.Shape();
        leftInwire
            .graphics
            .setStrokeStyle(this.halfAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(ag.x + Math.floor(this.andGate.height /4), this.andGate.width + ag.y)
            //.lineTo(ag.x + Math.floor(this.andGate.height /4), this.andGate.width + ag.y + this.bulbSize * this.tradius * 4)
            .lineTo(ag.x + Math.floor(this.andGate.height /4), this.xorChip.height + xorg.y + this.bulbSize * this.tradius * 4)
            .endStroke();
        this.container.addChild(leftInwire);


        const leftInwire2 = new createjs.Shape();
        leftInwire2
            .graphics
            .setStrokeStyle(this.halfAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(ag.x + Math.floor(this.andGate.height /4), ag.y + this.andGate.width + this.bulbSize * this.tradius * 2)
            .lineTo(ag.x + Math.floor(this.andGate.height /4) - this.bulbSize * this.tradius, ag.y + this.andGate.width + this.bulbSize * this.tradius * 2)
            .endStroke();
        this.container.addChild(leftInwire2);

        this.inLightLeft = new Light(this.tradius, this.halfAdderStrokeWidth, this.bulbSize);
        this.inLightLeft.container.x = ag.x + Math.floor(this.andGate.height /4) - this.bulbSize * this.tradius * 3;
        this.inLightLeft.container.y =  ag.y + this.andGate.width + this.bulbSize * this.tradius
        this.container.addChild(this.inLightLeft.container);







        const rightInWire = new createjs.Shape();
        rightInWire
            .graphics
            .setStrokeStyle(this.halfAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(ag.x + Math.floor(this.andGate.height /4 *3), this.andGate.width + ag.y)
            .lineTo(ag.x + Math.floor(this.andGate.height /4 * 3), this.xorChip.height + xorg.y + this.bulbSize * this.tradius * 4)
            .endStroke();
        this.container.addChild(rightInWire);



        const rightInwire2 = new createjs.Shape();
        rightInwire2
            .graphics
            .setStrokeStyle(this.halfAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(ag.x + Math.floor(this.andGate.height /4 * 3), ag.y + this.andGate.width + this.bulbSize * this.tradius * 2)
            .lineTo(ag.x + Math.floor(this.andGate.height /4 * 3) - this.bulbSize * this.tradius, ag.y + this.andGate.width + this.bulbSize * this.tradius * 2)
            .endStroke();
        this.container.addChild(rightInwire2);

        this.inLightRight = new Light(this.tradius, this.halfAdderStrokeWidth, this.bulbSize);
        this.inLightRight.container.x = ag.x + Math.floor(this.andGate.height /4 * 3) - this.bulbSize * this.tradius * 3;
        this.inLightRight.container.y =  ag.y + this.andGate.width + this.bulbSize * this.tradius
        this.container.addChild(this.inLightRight.container);










        const rightOutwire = new createjs.Shape();
        rightOutwire
            .graphics
            .setStrokeStyle(this.halfAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(xorg.x + Math.floor(this.xorChip.width /2), 0)
            .lineTo(xorg.x + Math.floor(this.xorChip.width /2), xorg.y)
            .endStroke();
        this.container.addChild(rightOutwire);


        const rightOutwire2 = new createjs.Shape();
        rightOutwire2
            .graphics
            .setStrokeStyle(this.halfAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(xorg.x + Math.floor(this.xorChip.width /2), Math.floor(xorg.y/2))
            .lineTo(xorg.x + Math.floor(this.xorChip.width /2) - this.bulbSize * this.tradius, Math.floor(xorg.y/2))
            .endStroke();
        this.container.addChild(rightOutwire2);

        this.outLightRight = new Light(this.tradius, this.halfAdderStrokeWidth, this.bulbSize);
        this.outLightRight.container.x = xorg.x + Math.floor(this.xorChip.width /2) - this.bulbSize * this.tradius * 3;
        this.outLightRight.container.y = Math.floor(xorg.y/2) - this.bulbSize * this.tradius;
        this.container.addChild(this.outLightRight.container);













//ddd
        const xorLeftInWire = new createjs.Shape();
        xorLeftInWire
            .graphics
            .setStrokeStyle(this.halfAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(this.xorChip.inLeft1X + xorg.x, this.xorChip.height + xorg.y)
            .lineTo(this.xorChip.inLeft1X + xorg.x, this.xorChip.height + xorg.y + this.bulbSize * this.tradius * 4)
            .endStroke();
        this.container.addChild(xorLeftInWire);

        const xorLeftInWire2 = new createjs.Shape();
        xorLeftInWire2
            .graphics
            .setStrokeStyle(this.halfAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(this.xorChip.inLeft1X + xorg.x, xorg.y + this.xorChip.height + this.bulbSize * this.tradius * 2)
            .lineTo(this.xorChip.inLeft1X + xorg.x - this.bulbSize * this.tradius, xorg.y + this.xorChip.height + this.bulbSize * this.tradius * 2)
            .endStroke();
        this.container.addChild(xorLeftInWire2);

        this.xorInLightLeft = new Light(this.tradius, this.halfAdderStrokeWidth, this.bulbSize, function(){
            const x = !THIS.input1;
            THIS.setInput(x, THIS.input2);
            THIS.stage.update();
        });
        this.xorInLightLeft.container.x = this.xorChip.inLeft1X + xorg.x - this.bulbSize * this.tradius * 3;
        this.xorInLightLeft.container.y =  xorg.y + this.xorChip.height + this.bulbSize * this.tradius 
        this.container.addChild(this.xorInLightLeft.container);





        const xorRightInWire = new createjs.Shape();
        xorRightInWire
            .graphics
            .setStrokeStyle(this.halfAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(this.xorChip.inRight1X + xorg.x, this.xorChip.height + xorg.y)
            .lineTo(this.xorChip.inRight1X + xorg.x, this.xorChip.height + xorg.y + this.bulbSize * this.tradius * 4)
            .endStroke();
        this.container.addChild(xorRightInWire);


        const xorRightInWire2 = new createjs.Shape();
        xorRightInWire2
            .graphics
            .setStrokeStyle(this.halfAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(this.xorChip.inRight1X + xorg.x, xorg.y + this.xorChip.height + this.bulbSize * this.tradius * 2)
            .lineTo(this.xorChip.inRight1X + xorg.x - this.bulbSize * this.tradius, xorg.y + this.xorChip.height + this.bulbSize * this.tradius * 2)
            .endStroke();
        this.container.addChild(xorRightInWire2);

        this.xorInLightRight = new Light(this.tradius, this.halfAdderStrokeWidth, this.bulbSize, function(){
            const x = !THIS.input2;
            THIS.setInput(THIS.input1, x);
            THIS.stage.update();
        });
        this.xorInLightRight.container.x = this.xorChip.inRight1X + xorg.x - this.bulbSize * this.tradius * 3;
        this.xorInLightRight.container.y =  xorg.y + this.xorChip.height + this.bulbSize * this.tradius 
        this.container.addChild(this.xorInLightRight.container);











        this.inLeftX = ag.x + Math.floor(this.andGate.height /2);
        this.inRightX = xorg.x + Math.floor(this.xorChip.width /2);

        const leftInWireZ = new createjs.Shape();
        leftInWireZ
            .graphics
            .setStrokeStyle(this.halfAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(ag.x + Math.floor(this.andGate.height /4), this.xorChip.height + xorg.y + this.bulbSize * this.tradius * 4)
            .lineTo(this.inLeftX, this.height)
            .endStroke();
        this.container.addChild(leftInWireZ);

        const leftInWireZ2 = new createjs.Shape();
        leftInWireZ2
            .graphics
            .setStrokeStyle(this.halfAdderStrokeWidth)
            .beginStroke("black")
            .moveTo(this.xorChip.inLeft1X + xorg.x, this.xorChip.height + xorg.y + this.bulbSize * this.tradius * 4)
            .lineTo(this.inLeftX, this.height)
            .endStroke();
        this.container.addChild(leftInWireZ2);



        const rightInWireZ = new createjs.Shape();
        rightInWireZ
            .graphics
            .setStrokeStyle(this.halfAdderStrokeWidth)
            .beginStroke("blue")
            .moveTo(ag.x + Math.floor(this.andGate.height /4 * 3), this.xorChip.height + xorg.y + this.bulbSize * this.tradius * 4)
            .lineTo(this.inRightX, this.height)
            .endStroke();
        this.container.addChild(rightInWireZ);

//ddd
        const rightInWireZ2 = new createjs.Shape();
        rightInWireZ2
            .graphics
            .setStrokeStyle(this.halfAdderStrokeWidth)
            .beginStroke("blue")
            .moveTo(this.xorChip.inRight1X + xorg.x, this.xorChip.height + xorg.y + this.bulbSize * this.tradius * 4)
            .lineTo(this.inRightX, this.height)
            .endStroke();
        this.container.addChild(rightInWireZ2);






                const dash = 20;



        this.outline = new createjs.Shape();
        this.outline
            .graphics
            .beginStroke("gray")
            .setStrokeStyle(this.halfAdderStrokeWidth)
            .setStrokeDash([dash, dash], 0)
            .beginFill("rgba(255, 255, 255, 0.01")
            .drawRect(0, 0, this.width, this.height)
        this.outline.name = "outline-" + this.coverName
        this.container.addChild(this.outline);




        this.coverContainer = new createjs.Container();
        this.coverContainer.name = this.coverName + "-container";
        this.cover = new createjs.Shape();
        this.cover.name = this.coverName;
        this.cover.graphics
            .beginStroke("black")
            .setStrokeStyle(this.halfAdderStrokeWidth)
            //.setStrokeDash([dash, dash], 0)
            .beginFill(this.coverColor)
            .drawRect(0, 0, this.width, this.height)
        this.coverContainer.addChild(this.cover);


        var text = new createjs.Text("Half Adder", this.tradius * 10 + "px Arial", "black");
        text.x = this.tradius * 7;
        text.y = this.tradius * 30;
        text.textBaseline = "alphabetic"
        //text.rotation = 90
        this.coverContainer.addChild(text)


        //this.cover.on("click", function(event) { console.log("clicked"); }, null, false, null, true)
        //this.cover.on("click", function(event) { console.log("clicked"); })

        this.container.addChild(this.coverContainer)







        this.setInput(this.input1, this.input2);

    }
}

class XorChip {
    constructor(stage, tradius, primStrokeWidth, subStrokeWidth, useCover) {

        const THIS = this;
        this.stage = stage;

        this.coverColor = "lightblue";
        this.coverName = "cover-" + (Math.random() * 99999999).toString();
        this.useCover = useCover;

        this.input1 = false;
        this.input2 = false;
        this.outut = false;

        this.bulbSize = XOR_BULB_SIZE;
        this.tradius = tradius;

        this.width = this.tradius * 38;
        this.height = this.tradius * 38;

        this.primStrokeWidth = primStrokeWidth;
        this.strokeWidth = subStrokeWidth;

        this.transistorGraphic = new TransistorGraphic(this.tradius, this.strokeWidth);
        this.resistorGraphic = new ResistorGraphic(this.tradius, this.strokeWidth);
        this.groundGraphic = new GroundGraphic(this.tradius, this.strokeWidth);
        
        this.container = new createjs.Container();


        this.orGate = new OrGate(this.stage, this.tradius, this.strokeWidth, this.transistorGraphic, this.resistorGraphic, this.groundGraphic, true);
        const og = this.orGate.container;//.clone(true);
        og.x = this.tradius + this.orGate.height / 2 + this.tradius * 2;
        og.y = this.tradius * 4;
        this.container.addChild(og);


        const outwire = new createjs.Shape();
        outwire
            .graphics
            .setStrokeStyle(this.primStrokeWidth)
            .beginStroke("black")
            .moveTo(Math.floor(this.width / 2), 0)
            .lineTo(Math.floor(this.width / 2), this.tradius * 4)
            .endStroke();
        this.container.addChild(outwire);

        this.outLight = new Light(this.tradius, this.primStrokeWidth, this.bulbSize);
        const outwire2 = new createjs.Shape();
        outwire2
            .graphics
            .setStrokeStyle(this.primStrokeWidth)
            .beginStroke("black")
            .moveTo(Math.floor(this.width / 2), this.tradius * 2)
            .lineTo(Math.floor(this.width / 2) - this.tradius * 2, this.tradius * 2)
            .endStroke();
        this.container.addChild(outwire2);



        this.outLight = new Light(this.tradius, this.primStrokeWidth, this.bulbSize);       
        this.outLight.container.x = Math.floor(this.width / 2) - this.tradius * 3;
        this.outLight.container.y = this.tradius;
        this.container.addChild(this.outLight.container)



        this.andGateLeft = new AndGate(this.stage, this.tradius, this.strokeWidth, this.transistorGraphic, this.resistorGraphic, this.groundGraphic, true, true);
        const agLeft = this.andGateLeft.container;//.clone(true);
        agLeft.x = this.tradius * 2;
        //agLeft.y = this.tradius;
        agLeft.y = og.y + this.orGate.width + this.tradius * 3;
        this.container.addChild(agLeft);

        this.andGateRight= new AndGate(this.stage, this.tradius, this.strokeWidth, this.transistorGraphic, this.resistorGraphic, this.groundGraphic, true, true);
        const agRight = this.andGateRight.container;//.clone(true);
        //agRight.x = this.tradius * 20;
        agRight.x = this.andGateRight.height + this.tradius * 4;
        agRight.y = og.y + this.orGate.width + this.tradius * 3;
        this.container.addChild(agRight);

        this.notGateLeft = new NotGate(this.stage, this.tradius, this.strokeWidth, this.transistorGraphic, this.resistorGraphic, this.groundGraphic, true);
        const nLeft = this.notGateLeft.container;//.clone(true);
        nLeft.x = agLeft.x;
        nLeft.y = agLeft.y + this.andGateLeft.width + this.tradius * 3;
        this.container.addChild(nLeft);

        this.notGateRight = new NotGate(this.stage, this.tradius, this.strokeWidth, this.transistorGraphic, this.resistorGraphic, this.groundGraphic, true);
        const nRight = this.notGateRight.container;//.clone(true);
        nRight.x = agRight.x + this.notGateRight.height;
        nRight.y = agRight.y + this.notGateRight.width + this.tradius * 3;
        this.container.addChild(nRight);








        const andNotLeftwire = new createjs.Shape();
        andNotLeftwire
            .graphics
            .setStrokeStyle(this.primStrokeWidth)
            .beginStroke("black")
            .moveTo(agLeft.x + Math.floor(this.andGateLeft.height / 4), agLeft.y + this.andGateLeft.width)
            .lineTo(agLeft.x + Math.floor(this.andGateLeft.height / 4), nLeft.y)
            .endStroke();
        this.container.addChild(andNotLeftwire);

        this.andNotLeftLight = new Light(this.tradius, this.primStrokeWidth, this.bulbSize);
        const andNotLeftwire2 = new createjs.Shape();
        andNotLeftwire2
            .graphics
            .setStrokeStyle(this.primStrokeWidth)
            .beginStroke("black")
            .moveTo(agLeft.x + Math.floor(this.andGateLeft.height / 4), agLeft.y + this.andGateLeft.width + Math.floor(this.tradius * 1.5))
            .lineTo(agLeft.x + Math.floor(this.andGateLeft.height / 6), agLeft.y + this.andGateLeft.width + Math.floor(this.tradius * 1.5))
            .endStroke();
        this.container.addChild(andNotLeftwire2);
        
        this.andNotLeftLight.container.x = Math.floor(this.tradius * 3);
        //this.andNotLeftLight.container.y = Math.floor(this.height / 4) - this.andNotLeftLight.radius * 3;
        this.andNotLeftLight.container.y = agLeft.y + this.andGateLeft.width + Math.floor(this.tradius * 0.5);
        
        this.container.addChild(this.andNotLeftLight.container);







        const andLeftwire2 = new createjs.Shape();
        andLeftwire2
            .graphics
            .setStrokeStyle(this.primStrokeWidth)
            .beginStroke("black")
            .moveTo(agLeft.x + Math.floor(this.andGateLeft.height / 4) + this.notGateLeft.height, agLeft.y + this.andGateLeft.width)
            .lineTo(agLeft.x + Math.floor(this.andGateLeft.height / 4) + this.notGateLeft.height, nLeft.y)
            .endStroke();
        this.container.addChild(andLeftwire2);

        this.andLeftLight2 = new Light(this.tradius, this.primStrokeWidth, this.bulbSize);
        const andLeftwire22 = new createjs.Shape();
        andLeftwire22
            .graphics
            .setStrokeStyle(this.primStrokeWidth)
            .beginStroke("black")
            .moveTo(agLeft.x + Math.floor(this.andGateLeft.height / 4) + this.notGateLeft.height, agLeft.y + this.andGateLeft.width + Math.floor(this.tradius * 1.5))
            .lineTo(agLeft.x + Math.floor(this.andGateLeft.height / 6) + this.notGateLeft.height, agLeft.y + this.andGateLeft.width + Math.floor(this.tradius * 1.5))
            .endStroke();
        this.container.addChild(andLeftwire22);
        
        this.andLeftLight2.container.x = Math.floor(this.tradius * 3) + this.notGateLeft.height;
        this.andLeftLight2.container.y = agLeft.y + this.andGateLeft.width + Math.floor(this.tradius * 0.5);
        
        this.container.addChild(this.andLeftLight2.container);







        const andNotRightwire = new createjs.Shape();
        andNotRightwire
            .graphics
            .setStrokeStyle(this.primStrokeWidth)
            .beginStroke("black")
            .moveTo(agRight.x + Math.floor(this.andGateRight.height / 4)  + this.notGateRight.width, agRight.y + this.andGateRight.width)
            .lineTo(agRight.x + Math.floor(this.andGateRight.height / 4)  + this.notGateRight.width, nRight.y)
            .endStroke();
        this.container.addChild(andNotRightwire);

        this.andNotRightLight = new Light(this.tradius, this.primStrokeWidth, this.bulbSize);
        const andNotRightwire2 = new createjs.Shape();
        andNotRightwire2
            .graphics
            .setStrokeStyle(this.primStrokeWidth)
            .beginStroke("black")
            .moveTo(agRight.x + Math.floor(this.andGateRight.height / 4)  + this.notGateRight.width, agRight.y + this.andGateRight.width + Math.floor(this.tradius * 1.5))
            .lineTo(agRight.x + Math.floor(this.andGateRight.height / 6)  + this.notGateRight.width, agRight.y + this.andGateRight.width + Math.floor(this.tradius * 1.5))
            .endStroke();
        this.container.addChild(andNotRightwire2);
        
        this.andNotRightLight.container.x = Math.floor(this.tradius * 21)  + this.notGateRight.width;
        this.andNotRightLight.container.y = agRight.y + this.andGateRight.width + Math.floor(this.tradius * 0.5);
        
        this.container.addChild(this.andNotRightLight.container);





        const andRightwire9 = new createjs.Shape();
        andRightwire9
            .graphics
            .setStrokeStyle(this.primStrokeWidth)
            .beginStroke("black")
            .moveTo(agRight.x + Math.floor(this.andGateRight.height / 4)  , agRight.y + this.andGateRight.width)
            .lineTo(agRight.x + Math.floor(this.andGateRight.height / 4)   , nRight.y)
            .endStroke();
        this.container.addChild(andRightwire9);

        this.andRightLight9 = new Light(this.tradius, this.primStrokeWidth, this.bulbSize);
        const andRightwire92 = new createjs.Shape();
        andRightwire92
            .graphics
            .setStrokeStyle(this.primStrokeWidth)
            .beginStroke("black")
            .moveTo(agRight.x + Math.floor(this.andGateRight.height / 4)  , agRight.y + this.andGateRight.width + Math.floor(this.tradius * 1.5))
            .lineTo(agRight.x + Math.floor(this.andGateRight.height / 6)  , agRight.y + this.andGateRight.width + Math.floor(this.tradius * 1.5))
            .endStroke();
        this.container.addChild(andRightwire92);
        
        this.andRightLight9.container.x = Math.floor(this.tradius * 13)  + this.notGateRight.width;
        this.andRightLight9.container.y = agRight.y + this.andGateRight.width + Math.floor(this.tradius * 0.5);
        
        this.container.addChild(this.andRightLight9.container);







        const orInLeftWire1 = new createjs.Shape();
        orInLeftWire1
            .graphics
            .setStrokeStyle(this.primStrokeWidth)
            .beginStroke("black")
            .moveTo(agLeft.x + Math.floor(this.andGateLeft.height / 2), agLeft.y)
            .lineTo(agLeft.x + Math.floor(this.andGateLeft.height / 2), og.y + this.orGate.width + this.tradius)
            .endStroke();
        this.container.addChild(orInLeftWire1);

        this.orInLeftLight = new Light(this.tradius, this.primStrokeWidth, this.bulbSize);
        const orInLeftWire2 = new createjs.Shape();
        orInLeftWire2
            .graphics
            .setStrokeStyle(this.primStrokeWidth)
            .beginStroke("black")
            .moveTo(agLeft.x + Math.floor(this.andGateLeft.height / 2) - this.tradius * 2, og.y + this.orGate.width + this.tradius)
            .lineTo(agLeft.x + Math.floor(this.andGateLeft.height / 2) + this.tradius * 5, og.y + this.orGate.width + this.tradius)
            .endStroke();
        this.container.addChild(orInLeftWire2);
        
        
        this.orInLeftLight.container.x = agLeft.x + Math.floor(this.andGateLeft.height / 2) - this.tradius * 3;
        this.orInLeftLight.container.y = og.y + this.orGate.width;
        
        this.container.addChild(this.orInLeftLight.container);









        const orInLeftWire3 = new createjs.Shape();
        orInLeftWire3
            .graphics
            .setStrokeStyle(this.primStrokeWidth)
            .beginStroke("black")
            .moveTo(agLeft.x + Math.floor(this.andGateLeft.height / 2) + this.tradius * 5, og.y + this.orGate.width + this.tradius)
            .lineTo(agLeft.x + Math.floor(this.andGateLeft.height / 2) + this.tradius * 5, og.y + this.orGate.width )
            .endStroke();
        this.container.addChild(orInLeftWire3);





        const orInRightWire1 = new createjs.Shape();
        orInRightWire1
            .graphics
            .setStrokeStyle(this.primStrokeWidth)
            .beginStroke("black")
            .moveTo(agRight.x + Math.floor(this.andGateLeft.height / 2), agRight.y)
            .lineTo(agRight.x + Math.floor(this.andGateLeft.height / 2), og.y + this.orGate.width + this.tradius)
            .endStroke();
        this.container.addChild(orInRightWire1);

        this.orInRightLight = new Light(this.tradius, this.primStrokeWidth, this.bulbSize);
        const orInRightWire2 = new createjs.Shape();
        orInRightWire2
            .graphics
            .setStrokeStyle(this.primStrokeWidth)
            .beginStroke("black")
            .moveTo(agRight.x + Math.floor(this.andGateLeft.height / 2) - this.tradius * 5, og.y + this.orGate.width + this.tradius)
            .lineTo(agRight.x + Math.floor(this.andGateLeft.height / 2) + this.tradius * 2, og.y + this.orGate.width + this.tradius)
            .endStroke();
        this.container.addChild(orInRightWire2);
        
        this.orInRightLight.container.x = agRight.x + Math.floor(this.andGateLeft.height / 2) + this.tradius * 1;
        this.orInRightLight.container.y = og.y + this.orGate.width;
        
        this.container.addChild(this.orInRightLight.container);


        const orInRightWire3 = new createjs.Shape();
        orInRightWire3
            .graphics
            .setStrokeStyle(this.primStrokeWidth)
            .beginStroke("black")
            .moveTo(agRight.x + this.tradius * 3, og.y + this.orGate.width + this.tradius)
            .lineTo(agRight.x + this.tradius * 3, og.y + this.orGate.width )
            .endStroke();
        this.container.addChild(orInRightWire3);







        this.inLeft1X = this.tradius * 10;


        const inLeft1 = new createjs.Shape();
        inLeft1
            .graphics
            .setStrokeStyle(this.primStrokeWidth)
            .beginStroke("black")
            .moveTo(this.tradius * 10, this.height)
            .lineTo(this.tradius * 6, this.height - this.tradius * 2)
            .endStroke();
        this.container.addChild(inLeft1);



        const inLeft2 = new createjs.Shape();
        inLeft1
            .graphics
            .setStrokeStyle(this.primStrokeWidth)
            .beginStroke("black")
            .moveTo(this.tradius * 10, this.height)
            .lineTo(this.tradius * 24, this.height - this.tradius * 12)
            .endStroke();
        this.container.addChild(inLeft1);

        const inLeft3 = new createjs.Shape();
        inLeft3
            .graphics
            .setStrokeStyle(this.primStrokeWidth)
            .beginStroke("black")
            .moveTo(this.tradius * 6, this.height - this.tradius * 2)
            .lineTo(this.tradius * 6, this.height - this.tradius * 4)
            .endStroke();
        this.container.addChild(inLeft3);

        const inLeft4 = new createjs.Shape();
        inLeft4
            .graphics
            .setStrokeStyle(this.primStrokeWidth)
            .beginStroke("black")
            .moveTo(this.tradius * 6, this.height - this.tradius * 2)
            .lineTo(this.tradius * 4, this.height - this.tradius * 2)
            .endStroke();
        this.container.addChild(inLeft4);

        this.inLeftLight = new Light(this.tradius, this.primStrokeWidth, this.bulbSize, function(){
            const input = !THIS.input1;
            THIS.setInput(input, THIS.input2);
            THIS.stage.update();
        });
        this.inLeftLight.container.x = this.tradius * 3
        this.inLeftLight.container.y = this.height - this.tradius * 3
        this.container.addChild(this.inLeftLight.container);




        // ddd
        this.inRight1X = this.width - this.tradius * 10



        const inRight1 = new createjs.Shape();
        inRight1
            .graphics
            .setStrokeStyle(this.primStrokeWidth)
            .beginStroke("blue")
            .moveTo(this.width - this.tradius * 10, this.height)
            .lineTo(this.width - this.tradius * 6, this.height - this.tradius * 2)
            .endStroke();
        this.container.addChild(inRight1);
        
        const inRight2 = new createjs.Shape();
        inRight2
            .graphics
            .setStrokeStyle(this.primStrokeWidth)
            .beginStroke("blue")
            .moveTo(this.width - this.tradius * 10, this.height)
            .lineTo(this.width - this.tradius * 24, this.height - this.tradius * 12)
            .endStroke();
        this.container.addChild(inRight2);

        const inRight3 = new createjs.Shape();
        inRight3
            .graphics
            .setStrokeStyle(this.primStrokeWidth)
            .beginStroke("blue")
            .moveTo(this.width - this.tradius * 6, this.height - this.tradius * 2)
            .lineTo(this.width - this.tradius * 6, this.height - this.tradius * 4)
            .endStroke();
        this.container.addChild(inRight3);

        const inRight4 = new createjs.Shape();
        inRight4
            .graphics
            .setStrokeStyle(this.primStrokeWidth)
            .beginStroke("blue")
            .moveTo(this.width - this.tradius * 6, this.height - this.tradius * 2)
            .lineTo(this.width - this.tradius * 4, this.height - this.tradius * 2)
            .endStroke();
        this.container.addChild(inRight4);

        this.inRightLight = new Light(this.tradius, this.primStrokeWidth, this.bulbSize, function(){
            const input = !THIS.input2;
            THIS.setInput(THIS.input1, input);
            THIS.stage.update();
        });
        this.inRightLight.container.x = this.width - this.tradius * 5
        this.inRightLight.container.y = this.height - this.tradius * 3
        this.container.addChild(this.inRightLight.container);










        /*const dash = DASH;

        const outline = new createjs.Shape();
        outline
            .graphics
            .beginStroke("gray")
            .setStrokeStyle(this.primStrokeWidth)
            .setStrokeDash([dash, dash], 0)
            .drawRect(0, 0, this.width, this.height);
        this.container.addChild(outline);*/







        const dash = DASH;



        this.outline = new createjs.Shape();
        this.outline
            .graphics
            .beginStroke("gray")
            .setStrokeStyle(this.primStrokeWidth)
            .setStrokeDash([dash, dash], 0)
            .beginFill("rgba(255, 255, 255, 0.01")
            .drawRect(0, 0, this.width, this.height)
        this.outline.name = "outline-" + this.coverName
        this.container.addChild(this.outline);




        this.coverContainer = new createjs.Container();
        this.coverContainer.name = this.coverName + "-container";
        this.cover = new createjs.Shape();
        this.cover.name = this.coverName;
        this.cover.graphics
            .beginStroke("black")
            .setStrokeStyle(this.primStrokeWidth)
            //.setStrokeDash([dash, dash], 0)
            .beginFill(this.coverColor)
            .drawRect(0, 0, this.width, this.height)
        this.coverContainer.addChild(this.cover);


        var text = new createjs.Text("Xor", this.tradius * 16 + "px Arial", "black");
        text.x = this.tradius * 7;
        text.y = this.tradius * 24;
        text.textBaseline = "alphabetic"
        //text.rotation = 90
        this.coverContainer.addChild(text)


        //this.cover.on("click", function(event) { console.log("clicked"); }, null, false, null, true)
        //this.cover.on("click", function(event) { console.log("clicked"); })

        this.container.addChild(this.coverContainer)







        this.setInput(this.input1, this.input2);
    }

    setInput(value1, value2) {
        this.input1 = value1;
        this.input2 = value2;

        this.notGateLeft.setInput(this.input1);
        this.notGateRight.setInput(this.input2);
        


        if (this.notGateLeft.getOutput()) {
            this.andNotLeftLight.fillCommand.style = LIGHT_ON_COLOR;
        } else {
            this.andNotLeftLight.fillCommand.style = LIGHT_OFF_COLOR;
        }

        if (this.input2) {
            this.andLeftLight2.fillCommand.style = LIGHT_ON_COLOR;
            this.inRightLight.fillCommand.style = LIGHT_ON_COLOR;
        } else {
            this.andLeftLight2.fillCommand.style = LIGHT_OFF_COLOR;
            this.inRightLight.fillCommand.style = LIGHT_OFF_COLOR;
        }

        if (this.notGateRight.getOutput()) {
            this.andNotRightLight.fillCommand.style = LIGHT_ON_COLOR;
        } else {
            this.andNotRightLight.fillCommand.style = LIGHT_OFF_COLOR;
        }

        if (this.input1) {
            this.andRightLight9.fillCommand.style = LIGHT_ON_COLOR;
            this.inLeftLight.fillCommand.style = LIGHT_ON_COLOR;
        } else {
            this.andRightLight9.fillCommand.style = LIGHT_OFF_COLOR;
            this.inLeftLight.fillCommand.style = LIGHT_OFF_COLOR;
        }
        

        this.andGateLeft.setInput(this.notGateLeft.getOutput(), this.input2);
        this.andGateRight.setInput(this.input1, this.notGateRight.getOutput());

        this.orGate.setInput(this.andGateLeft.getOutput(), this.andGateRight.getOutput());


        if (this.orGate.input1) {
            this.orInLeftLight.fillCommand.style = LIGHT_ON_COLOR;
        } else {
            this.orInLeftLight.fillCommand.style = LIGHT_OFF_COLOR;
        }

        if (this.orGate.input2) {
            this.orInRightLight.fillCommand.style = LIGHT_ON_COLOR;
        } else {
            this.orInRightLight.fillCommand.style = LIGHT_OFF_COLOR;
        }







        this.output = this.orGate.getOutput();

        if (this.output) {
            this.outLight.fillCommand.style = LIGHT_ON_COLOR;
        } else {
            this.outLight.fillCommand.style = LIGHT_OFF_COLOR;
        }
    }

    getOutput() {
        return this.output;
    }
}

class AndChip {
    constructor(stage, tradius, strokeWidth) {
        this.stage = stage;
        this.input1 = false;
        this.input2 = false;
        this.outut = false;

        this.tradius = tradius;
        this.strokeWidth = strokeWidth;

        this.transistorGraphic = new TransistorGraphic(this.tradius, this.strokeWidth);
        this.resistorGraphic = new ResistorGraphic(this.tradius, this.strokeWidth);
        this.groundGraphic = new GroundGraphic(this.tradius, this.strokeWidth);
        
        this.container = new createjs.Container();
        this.andGate = new AndGate(this.stage, this.tradius, this.strokeWidth, this.transistorGraphic, this.resistorGraphic, this.groundGraphic, true, true);
        this.width = this.andGate.height;
        this.height = this.andGate.width;

        /*const ag = this.andGate.container.clone(true);
        ag.x = 0;
        ag.y = 0;
        this.container.addChild(ag);*/
        this.container.addChild(this.andGate.container)

        /*this.notGate = new NotGate(this.tradius, this.strokeWidth, this.transistorGraphic, this.resistorGraphic, this.groundGraphic, true);
        const n = this.notGate.container.clone(true);
        n.x = this.andGate.height + 10;
        n.y = 0;
        this.container.addChild(n);*/

        this.setInput(this.input1, this.input2);
    }

    setInput(value1, value2) {
        this.input1 = value1;
        this.input2 = value2;
        this.andGate.setInput(value1, value2);
        //this.notGate.setInput(this.andGate.getOutput());
        //this.output = this.notGate.getOutput();
        this.output = this.andGate.output;
    }

    getOutput() {
        return this.output;
    }
}

class OrChip {
    constructor(stage, tradius, strokeWidth) {
        this.stage = stage;
        this.input1 = false;
        this.input2 = false;
        this.outut = false;

        this.tradius = tradius;
        this.strokeWidth = strokeWidth;

        this.transistorGraphic = new TransistorGraphic(this.tradius, this.strokeWidth);
        this.resistorGraphic = new ResistorGraphic(this.tradius, this.strokeWidth);
        this.groundGraphic = new GroundGraphic(this.tradius, this.strokeWidth);
        
        this.container = new createjs.Container();
        this.orGate = new OrGate(this.stage, this.tradius, this.strokeWidth, this.transistorGraphic, this.resistorGraphic, this.groundGraphic, true);
        this.width = this.orGate.height;
        this.height = this.orGate.width;

        const og = this.orGate.container;//.clone(true);
        og.x = 0;
        og.y = 0;
        this.container.addChild(og);

        /*this.notGate = new NotGate(this.tradius, this.strokeWidth, this.transistorGraphic, this.resistorGraphic, this.groundGraphic, true);
        const n = this.notGate.container;//.clone(true);
        n.x = this.orGate.height + 10;
        n.y = 0;
        this.container.addChild(n);*/

        this.setInput(this.input1, this.input2);
    }

    setInput(value1, value2) {
        this.input1 = value1;
        this.input2 = value2;
        this.orGate.setInput(value1, value2);
        //this.notGate.setInput(this.orGate.getOutput());
        this.output = this.orGate.getOutput();
    }

    getOutput() {
        return this.output;
    }
}

class NotNotChip {
    constructor(stage, tradius, strokeWidth) {
        this.stage = stage;
        this.input = false;
        this.outut = false;


        this.tradius = tradius;
        this.strokeWidth = strokeWidth;

        this.transistorGraphic = new TransistorGraphic(this.tradius, this.strokeWidth);
        this.resistorGraphic = new ResistorGraphic(this.tradius, this.strokeWidth);
        this.groundGraphic = new GroundGraphic(this.tradius, this.strokeWidth);
        
        this.container = new createjs.Container();
        this.notGate = new NotGate(this.stage, this.tradius, this.strokeWidth, this.transistorGraphic, this.resistorGraphic, this.groundGraphic, true);
        //this.notGate2 = new NotGate(this.tradius, this.strokeWidth, this.transistorGraphic, this.resistorGraphic, this.groundGraphic, true);
        this.width = this.notGate.height;
        this.height = this.notGate.width;

        const n = this.notGate.container;//.clone(true);
        n.x = 0;
        n.y = 100;
        this.container.addChild(n);

        /*const n2 = this.notGate2.container.clone(true);
        n2.x = 400;
        n2.y = 100;
        this.container.addChild(n2);*/

        this.setInput(this.input);
    }

    setInput(value) {
        this.input = value;
        this.notGate.setInput(value);
        //this.notGate2.setInput(this.notGate.getOutput());
        this.output = this.notGate.getOutput();
    }

    getOutput() {
        return this.output;
    }
}

class Camera {
    constructor(stage, container, canvas, dragSurface, scale) {
        this.foo = false;
        this.stage = stage;
        this.container = container;
        this.canvas = canvas;
        this.dragSurface = dragSurface;
        this.stageTween = null;

        this.dragStart = null;

        // The coordinates for the center of the *container* (not the stage)
        this.center = {
            x: 0,
            y: 0,
        };

        this.placeCamera();
        this.zoom(scale);

        const THIS = this;

        this.canvas.onwheel = function(event) {
            THIS.wheel(event);
        };

        this.dragSurface.on("pressmove", function(evt) {
            //console.log("asdf")
            THIS.pressmove(evt);
        });

        this.dragSurface.on("pressup", function(evt) {
            THIS.pressup(evt);
        });
    }

    pressmove(evt) {
        //console.log("pressmove");

        if (!this.dragStart) {
            this.dragStart = {
                x: evt.stageX - this.container.x,
                y: evt.stageY - this.container.y,
            };
            this.containerStart = this.dragStart;
            this.cameraCenterStart = {
                x: this.center.x,
                y: this.center.y,
            };
            //console.log(this.dragStart);
        } else {
            this.containerStart = {
                x: evt.stageX - this.container.x + this.containerStart.x - this.dragStart.x,
                y: evt.stageY - this.container.y + this.containerStart.y - this.dragStart.y,
            }
        }

        const newCameraCenter = {
            x: this.dragStart.x - this.containerStart.x + this.cameraCenterStart.x,
            y: this.dragStart.y - this.containerStart.y + this.cameraCenterStart.y,
        };

        this.center = newCameraCenter;
        //console.log(this.viz.camera.center);

        this.placeCamera();
        this.stage.update();

    }

    pressup(evt) {
        //console.log("pressup");
        this.dragStart = null;
    }

    wheel(event) {


        if (this.foo) {
            return;
        }

        // TODO: If stage tween then disable zoom
        event.preventDefault();



        var x = event.pageX - $('#' + this.canvas.id).offset().left;
        var y = event.pageY - $('#' + this.canvas.id).offset().top;


        console.log("x,y", x,y)

        //this.container.regX = 0;
        //this.container.regY = 0;

        //https://createjs.com/tutorials/HitTest/
        var containerPt = this.container.globalToLocal(x, y);
        console.log("cp", containerPt.x, containerPt.y);

        //this.container.regX = containerPt.x;
        //this.container.regY = containerPt.y;

        let scale = this.scale;
        scale += event.deltaY * 0.0003;

        // Restrict scale
        scale = Math.min(Math.max(MIN_ZOOM, scale), MAX_ZOOM);

        //this.viz.pan();
        //this.placeCamera();
        this.zoom(scale);




        const containerPtAfter = this.container.globalToLocal(x, y);

        //const dx = containerPtAfter.x - containerPt.x;
        //const dy = containerPtAfter.y - containerPt.y;



        console.log("After", containerPtAfter.x, containerPtAfter.y);
        
        const dx = containerPtAfter.x - containerPt.x;
        const dy = containerPtAfter.y - containerPt.y;

        console.log("d", dx, dy);

        // this.container.x += dx;
        // this.container.y += dy;


        const containerPtAfter2 = this.container.globalToLocal(x, y);

        console.log("2", containerPtAfter2.x, containerPtAfter2.y);


        //const dglobal = this.container.localToGlobal(dx, dy, this.stage)
        const dglobal = this.container.localToGlobal(containerPt.x, containerPt.y)//, this.stage)
        console.log("global", dglobal.x, dglobal.y);
        

        console.log("diff", containerPtAfter.x - containerPt.x);

            console.log()



        this.container.x += (containerPtAfter.x - containerPt.x) * this.scale;
        this.container.y += (containerPtAfter.y - containerPt.y) * this.scale;
        //this.container.x -= dglobal.x;
        //this.container.y -= dglobal.y;

        //this.container.x = x;
        //this.container.y = y;


        //this.foo = true;

        this.stage.update();
        //this.viz.stage.update();

    }

    zoom(scale) {
        this.scale = scale;
        this.container.scaleX = this.scale;
        this.container.scaleY = this.scale;
        //console.log(this.scale);
    }


    placeCamera() {
        //console.log("placeCamera")
        this.container.x = this.canvas.width / 2 - this.center.x;
        this.container.y = this.canvas.height / 2 - this.center.y;
    }
}



const canvasId = "circuit-canvas-1";
const stage = new createjs.Stage(canvasId);
stage.enableMouseOver();
//const xorChip = new NotNotChip(stage, TRADIUS, STROKE_WIDTH);
//const xorChip = new AndChip(stage, TRADIUS, STROKE_WIDTH);
//notNotChip.container.x = 100;
//stage.addChild(notNotChip.container);

//const xorChip = new OrChip(stage, TRADIUS, STROKE_WIDTH)
//stage.addChild(orChip.container)


//const xorChip = new FullAdder(stage, TRADIUS, FULL_ADDER_STROKE_WIDTH, HALF_ADDER_STROKE_WIDTH, XOR_STROKE_WIDTH, STROKE_WIDTH);
const xorChip = new FourBitAdder(stage, TRADIUS, FOUR_BIT_ADDER_STROKE_WIDTH, FULL_ADDER_STROKE_WIDTH, HALF_ADDER_STROKE_WIDTH, XOR_STROKE_WIDTH, STROKE_WIDTH);


//const xorChip = new XorChip(stage, TRADIUS, XOR_STROKE_WIDTH, STROKE_WIDTH, true)
xorChip.container.x = -xorChip.width / 2;
xorChip.container.y = -xorChip.height / 2;

const rootContainer = new createjs.Container();
rootContainer.addChild(xorChip.container);

const CANVAS_WIDTH = 1000;
const CANVAS_HEIGHT = 500;
const CANVAS = document.getElementById("circuit-canvas-1");




        const dragSurface = new createjs.Shape();
        dragSurface
            .graphics
            .beginFill("white")//"rgba(255, 255, 0, 0.51")
            .drawRect(0, 0, CANVAS.width, CANVAS.height)
            //.drawRect(-100, -100, 1000, 1000)

        //console.log(dragSurface)
        //dragSurface.addChild(dragSurfaceOutline);
stage.addChild(dragSurface);

const camera = new Camera(stage, rootContainer, CANVAS, dragSurface, 0.03);




stage.addChild(rootContainer);




stage.update();


// https://stackoverflow.com/questions/54398197/mouse-click-through-top-image
stage.on("stagemouseup", function(event) {

    var objs = stage.getObjectsUnderPoint(event.stageX, event.stageY);

    console.log(objs)

    if (objs.length == 0) {
        return;
    }


    //objs[0].rmCover();
    //return objs[0];
    const c = objs[0];
    console.log(c.name)

    if (!c.name) {
        return;
    }


    console.log(c.name)


    if (c.name.startsWith("outline")) {
        //console.log(1)
            const children = recur(stage);
            const [child, parent] = getStageItem(c.name, children);
            //console.log(c, child)
            parent.removeChild(child);
            stage.update();

        return;
    }

    if (!c.name.startsWith("cover-")) {
        console.log("not cover")
        return;
    }

    const children = recur(stage);
    const [child, parent] = getStageItem(c.name + "-container", children);
    //console.log(c, child)
    parent.removeChild(child);
    stage.update();
    //console.log(objs[0]);
    return;
    /*(for (var i=0, l=objs.length; i<l; i++) {
      var obj = objs[i];
      if (obj == firstElement || obj == secondElement) { doSomething(); break; }
    }*/
});


//let circuit1;
//function main() {

    //circuit1 = new Circuit(500, 300, "circuit-canvas-1", TRADIUS, STROKE_WIDTH);
    //const t1 = new TransistorGraphic(10, 10);
    //circuit1.addItem(t1);

    /*const t = circuit1.transistorGraphic.container.clone(true);
    t.x = 100;
    t.y = 100;
    //circuit1.stage.addChild(t);*/

    /*
    const n = circuit1.notGateGraphic.container.clone(true);
    n.x = 200;
    n.y = 100;
    circuit1.stage.addChild(n);

    const n2 = circuit1.notGateGraphic.container.clone(true);
    n2.x = 500;
    n2.y = 100;
    circuit1.stage.addChild(n2);*/

    //circuit1.stage.update();
//}